<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>mc2: GfxData Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>GfxData Class Reference</h1>Contains all graphical information about one item.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="GfxData_8h-source.html">GfxData.h</a>&gt;</code>
<p>
Inheritance diagram for GfxData:<p><center><img src="classGfxData__inherit__graph.png" border="0" usemap="#GfxData__inherit__map" alt="Inheritance graph"></center>
<map name="GfxData__inherit__map">
<area href="classGfxDataFull.html" shape="rect" coords="11,80,101,107" alt="">
<area href="classGfxDataMultiplePoints.html" shape="rect" coords="125,80,277,107" alt="">
<area href="classGfxDataSingleLine.html" shape="rect" coords="301,80,435,107" alt="">
<area href="classGfxDataSinglePoint.html" shape="rect" coords="459,80,597,107" alt="">
<area href="classGfxDataSingleSmallPoly.html" shape="rect" coords="621,80,787,107" alt="">
<area href="classGMSGfxData.html" shape="rect" coords="5,155,107,181" alt="">
</map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center><a href="classGfxData-members.html">List of all members.</a><h2>Public Types</h2>
<ul>
<li>typedef <a class="el" href="Types_8h.html#a22">int32</a> <a class="el" href="classGfxData.html#w0">coordinate_type</a>
<dl class="el"><dd class="mdescRight">Numeric type of coordinates.  <a href="#w0"></a><br></dl><li>typedef <a class="el" href="classMC2Coordinate.html">MC2Coordinate</a> * <a class="el" href="classGfxData.html#w1">iterator</a>
<dl class="el"><dd class="mdescRight">Ordinary iterator for all coordinates in a polygon.  <a href="#w1"></a><br></dl><li>typedef const <a class="el" href="classMC2Coordinate.html">MC2Coordinate</a> * <a class="el" href="classGfxData.html#w2">const_iterator</a>
<dl class="el"><dd class="mdescRight">Ordinary const iterator for all coordinates in a polygon.  <a href="#w2"></a><br></dl><li>typedef <a class="el" href="classGfxDataFilterIterator.html">GfxDataFilterIterator</a> <a class="el" href="classGfxData.html#w3">const_filter_iterator</a>
<dl class="el"><dd class="mdescRight">The filter iterator. Operates on coordinates, not polygons.  <a href="#w3"></a><br></dl><li>enum <a class="el" href="classGfxData.html#w9">gfxdata_t</a> { <br>
&nbsp;&nbsp;<a class="el" href="classGfxData.html#w9w4">gfxDataFull</a> =  0, 
<a class="el" href="classGfxData.html#w9w5">gfxDataSingleSmallPoly</a>, 
<a class="el" href="classGfxData.html#w9w6">gfxDataSingleLine</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="classGfxData.html#w9w7">gfxDataSinglePoint</a>, 
<a class="el" href="classGfxData.html#w9w8">gfxDataMultiplePoints</a>
<br>
 }
</ul>
<h2>Public Member Functions</h2>
<ul>
<li><a class="el" href="classGfxData.html#a0">GfxData</a> ()
<dl class="el"><dd class="mdescRight">Creates an empty GfxData.  <a href="#a0"></a><br></dl><li>virtual <a class="el" href="classGfxData.html#a1">~GfxData</a> ()
<dl class="el"><dd class="mdescRight">Since this class have to be abstract, we need a proper destructor.  <a href="#a1"></a><br></dl><li>virtual <a class="el" href="classMC2Coordinate.html">const_iterator</a> <a class="el" href="classGfxData.html#a2">polyBegin</a> (<a class="el" href="Types_8h.html#a19">uint16</a> p) const =0
<dl class="el"><dd class="mdescRight">Returns the begin iterator for polygon p.  <a href="#a2"></a><br></dl><li>virtual <a class="el" href="classMC2Coordinate.html">const_iterator</a> <a class="el" href="classGfxData.html#a3">polyEnd</a> (<a class="el" href="Types_8h.html#a19">uint16</a> p) const =0
<dl class="el"><dd class="mdescRight">Returns the end iterator for polygon p.  <a href="#a3"></a><br></dl><li>virtual <a class="el" href="classMC2Coordinate.html">iterator</a> <a class="el" href="classGfxData.html#a4">polyBegin</a> (<a class="el" href="Types_8h.html#a19">uint16</a> p)=0
<dl class="el"><dd class="mdescRight">Returns the begin iterator for polygon p.  <a href="#a4"></a><br></dl><li>virtual <a class="el" href="classMC2Coordinate.html">iterator</a> <a class="el" href="classGfxData.html#a5">polyEnd</a> (<a class="el" href="Types_8h.html#a19">uint16</a> p)=0
<dl class="el"><dd class="mdescRight">Returns the end iterator for polygon p.  <a href="#a5"></a><br></dl><li>virtual <a class="el" href="classGfxData.html#w0">coordinate_type</a> <a class="el" href="classGfxData.html#a6">getLat</a> (<a class="el" href="Types_8h.html#a19">uint16</a> p, <a class="el" href="Types_8h.html#a21">uint32</a> i) const =0
<li>virtual <a class="el" href="classGfxData.html#w0">coordinate_type</a> <a class="el" href="classGfxData.html#a7">getLon</a> (<a class="el" href="Types_8h.html#a19">uint16</a> p, <a class="el" href="Types_8h.html#a21">uint32</a> i) const =0
<li>virtual <a class="el" href="Types_8h.html#a19">uint16</a> <a class="el" href="classGfxData.html#a8">getNbrPolygons</a> () const =0
<li>virtual <a class="el" href="Types_8h.html#a21">uint32</a> <a class="el" href="classGfxData.html#a9">getNbrCoordinates</a> (<a class="el" href="Types_8h.html#a19">uint16</a> poly) const =0
<li><a class="el" href="Types_8h.html#a21">uint32</a> <a class="el" href="classGfxData.html#a10">getTotalNbrCoordinates</a> () const 
<li><a class="el" href="classMC2Coordinate.html">MC2Coordinate</a> <a class="el" href="classGfxData.html#a11">getCoordinate</a> (<a class="el" href="Types_8h.html#a19">uint16</a> p, <a class="el" href="Types_8h.html#a21">uint32</a> i) const 
<dl class="el"><dd class="mdescRight">Gets coordinate for a specific polygon and segment.  <a href="#a11"></a><br></dl><li><a class="el" href="classGfxDataFilterIterator.html">const_filter_iterator</a> <a class="el" href="classGfxData.html#a12">beginFilteredPoly</a> (<a class="el" href="Types_8h.html#a19">uint16</a> polyIdx, <a class="el" href="Types_8h.html#a17">uint8</a> filterLevel) const 
<dl class="el"><dd class="mdescRight">Begin iterator for polygon polyIdx.  <a href="#a12"></a><br></dl><li><a class="el" href="classGfxDataFilterIterator.html">const_filter_iterator</a> <a class="el" href="classGfxData.html#a13">endFilteredPoly</a> (<a class="el" href="Types_8h.html#a19">uint16</a> polyIdx, <a class="el" href="Types_8h.html#a17">uint8</a> filterLevel) const 
<dl class="el"><dd class="mdescRight">End iterator for polygon polyIdx.  <a href="#a13"></a><br></dl><li>virtual bool <a class="el" href="classGfxData.html#a14">sortPolygons</a> ()=0
<dl class="el"><dd class="mdescRight">Sort the polygons by the number of coordinates they have.  <a href="#a14"></a><br></dl><li>virtual void <a class="el" href="classGfxData.html#a15">setClosed</a> (<a class="el" href="Types_8h.html#a19">uint16</a> poly, bool closed)=0
<li>virtual bool <a class="el" href="classGfxData.html#a16">getClosed</a> (<a class="el" href="Types_8h.html#a19">uint16</a> poly) const =0
<li>virtual <a class="el" href="classGfxData.html#w0">coordinate_type</a> <a class="el" href="classGfxData.html#a17">getMinLat</a> () const =0
<dl class="el"><dd class="mdescRight">Get the minimum latitude.  <a href="#a17"></a><br></dl><li>virtual <a class="el" href="classGfxData.html#w0">coordinate_type</a> <a class="el" href="classGfxData.html#a18">getMaxLat</a> () const =0
<dl class="el"><dd class="mdescRight">Get the maximum latitude.  <a href="#a18"></a><br></dl><li>virtual <a class="el" href="classGfxData.html#w0">coordinate_type</a> <a class="el" href="classGfxData.html#a19">getMinLon</a> () const =0
<dl class="el"><dd class="mdescRight">Get the minimum longitude.  <a href="#a19"></a><br></dl><li>virtual <a class="el" href="classGfxData.html#w0">coordinate_type</a> <a class="el" href="classGfxData.html#a20">getMaxLon</a> () const =0
<dl class="el"><dd class="mdescRight">Get the maximum longitude.  <a href="#a20"></a><br></dl><li>virtual <a class="el" href="Types_8h.html#a27">float64</a> <a class="el" href="classGfxData.html#a21">getCosLat</a> () const =0
<li>virtual <a class="el" href="Types_8h.html#a27">float64</a> <a class="el" href="classGfxData.html#a22">getLength</a> (<a class="el" href="Types_8h.html#a19">uint16</a> p) const =0
<dl class="el"><dd class="mdescRight">Returns the length in meters.  <a href="#a22"></a><br></dl><li><a class="el" href="Types_8h.html#a27">float64</a> <a class="el" href="classGfxData.html#a23">calcPolyLength</a> (<a class="el" href="Types_8h.html#a21">uint32</a> polyIdx) const 
<dl class="el"><dd class="mdescRight">Calculates the length of polygon <code>polyIndex</code>.  <a href="#a23"></a><br></dl><li>virtual void <a class="el" href="classGfxData.html#a24">setLength</a> (<a class="el" href="Types_8h.html#a19">uint16</a> p, <a class="el" href="Types_8h.html#a27">float64</a> length)=0
<dl class="el"><dd class="mdescRight">Note! length is in mm.  <a href="#a24"></a><br></dl><li>virtual bool <a class="el" href="classGfxData.html#a25">updateLength</a> (<a class="el" href="Types_8h.html#a19">uint16</a> polindex=MAX_UINT16)=0
<dl class="el"><dd class="mdescRight">Calculates the lengths of the polygons.  <a href="#a25"></a><br></dl><li>virtual bool <a class="el" href="classGfxData.html#a26">updateBBox</a> ()=0
<li>virtual bool <a class="el" href="classGfxData.html#a27">updateBBox</a> (const <a class="el" href="classGfxData.html#w0">coordinate_type</a> lat, const <a class="el" href="classGfxData.html#w0">coordinate_type</a> lon)=0
<li>virtual <a class="el" href="Types_8h.html#a21">uint32</a> <a class="el" href="classGfxData.html#a28">getMemoryUsage</a> () const 
<dl class="el"><dd class="mdescRight">Get the memory usage of this object.  <a href="#a28"></a><br></dl><li><a class="el" href="classGfxData.html#w9">gfxdata_t</a> <a class="el" href="classGfxData.html#a29">getGfxDataType</a> () const 
<li>void <a class="el" href="classGfxData.html#a30">createFromDataBuffer</a> (<a class="el" href="classDataBuffer.html">DataBuffer</a> *dataBuffer)
<li>bool <a class="el" href="classGfxData.html#a31">getPolygonCentroid</a> (const <a class="el" href="Types_8h.html#a21">uint32</a> polygon, <a class="el" href="Types_8h.html#a22">int32</a> &amp;centroidLat, <a class="el" href="Types_8h.html#a22">int32</a> &amp;centroidLon) const 
<dl class="el"><dd class="mdescRight">Method used for text labeling of features described with closed polygons.  <a href="#a31"></a><br></dl><li>bool <a class="el" href="classGfxData.html#a32">getPolygonCentroid</a> (<a class="el" href="Types_8h.html#a21">uint32</a> polygon, <a class="el" href="classMC2Coordinate.html">MC2Coordinate</a> &amp;coord) const 
<dl class="el"><dd class="mdescRight">above  <a href="#a32"></a><br></dl><li>bool <a class="el" href="classGfxData.html#a33">convexPolygon</a> (const <a class="el" href="Types_8h.html#a21">uint32</a> polygon) const 
<dl class="el"><dd class="mdescRight">Finds out if a given simple polygon is convex, i.e all lines drawn between any pair of nodes are entirely inside of or on the boundary of the polygon.  <a href="#a33"></a><br></dl><li>double <a class="el" href="classGfxData.html#a34">getCosRelativeAngle</a> (<a class="el" href="Types_8h.html#a22">int32</a> polyIndex, <a class="el" href="Types_8h.html#a21">uint32</a> p, <a class="el" href="Types_8h.html#a21">uint32</a> tip, <a class="el" href="Types_8h.html#a21">uint32</a> q)
<dl class="el"><dd class="mdescRight">Finds the cosine of the relative angle between two consecutive segments in a simple polygon.  <a href="#a34"></a><br></dl><li>void <a class="el" href="classGfxData.html#a35">save</a> (<a class="el" href="classDataBuffer.html">DataBuffer</a> &amp;dataBuffer) const 
<dl class="el"><dd class="mdescRight">Save the data in a data buffer.  <a href="#a35"></a><br></dl><li><a class="el" href="Types_8h.html#a21">uint32</a> <a class="el" href="classGfxData.html#a36">getSizeInDataBuffer</a> () const 
<dl class="el"><dd class="mdescRight">Returns the size (in bytes) of the GfxData when saved as a <a class="el" href="classDataBuffer.html">DataBuffer</a>.  <a href="#a36"></a><br></dl><li>bool <a class="el" href="classGfxData.html#a37">equals</a> (<a class="el" href="Types_8h.html#a19">uint16</a> thisPolygon, <a class="el" href="Types_8h.html#a21">uint32</a> thisCoord, const <a class="el" href="classGfxData.html">GfxData</a> *otherGfx, <a class="el" href="Types_8h.html#a19">uint16</a> otherPolygon, <a class="el" href="Types_8h.html#a21">uint32</a> otherCoord, <a class="el" href="Types_8h.html#a19">uint16</a> factor=1) const 
<dl class="el"><dd class="mdescRight">Find out if this GfxData is equal to another one.  <a href="#a37"></a><br></dl><li>bool <a class="el" href="classGfxData.html#a38">equals</a> (const <a class="el" href="classGfxData.html">GfxData</a> *otherData) const 
<dl class="el"><dd class="mdescRight">Find out if this GfxData is equal to another GfxData.  <a href="#a38"></a><br></dl><li>bool <a class="el" href="classGfxData.html#a39">getConvexHull</a> (<a class="el" href="classStack.html">Stack</a> *stack, <a class="el" href="Types_8h.html#a19">uint16</a> polygon)
<dl class="el"><dd class="mdescRight">Calculates the convex hull of a polygon using Grahams scan.  <a href="#a39"></a><br></dl><li><a class="el" href="classGfxData.html">GfxData</a> * <a class="el" href="classGfxData.html#a40">createNewConvexHull</a> () const 
<dl class="el"><dd class="mdescRight">Calculates the convex hull for all the polygons of the GfxData and returns a new GfxData created by GfxData::createGfxData(NULL).  <a href="#a40"></a><br></dl><li><a class="el" href="classGfxData.html">GfxData</a> * <a class="el" href="classGfxData.html#a41">getConvexHull</a> (const <a class="el" href="classGfxData.html">GfxData</a> *pointSet)
<dl class="el"><dd class="mdescRight">Calculates the convex hull of a set of points using Jarvi's March method.  <a href="#a41"></a><br></dl><li>bool <a class="el" href="classGfxData.html#a42">getSimplifiedPolygon</a> (<a class="el" href="classStack.html">Stack</a> *stack, <a class="el" href="Types_8h.html#a19">uint16</a> polygon, <a class="el" href="Types_8h.html#a21">uint32</a> maxDist, <a class="el" href="Types_8h.html#a21">uint32</a> minDist) const 
<dl class="el"><dd class="mdescRight">Get the indices of a simplified CLOSED polygon.  <a href="#a42"></a><br></dl><li>bool <a class="el" href="classGfxData.html#a43">openPolygonFilter</a> (<a class="el" href="classStack.html">Stack</a> *newPoly, <a class="el" href="Types_8h.html#a21">uint32</a> polyIndex, <a class="el" href="Types_8h.html#a21">uint32</a> maxLatDist, <a class="el" href="Types_8h.html#a21">uint32</a> maxWayDist, bool minimizeError=false, <a class="el" href="Types_8h.html#a21">uint32</a> startIndex=0, <a class="el" href="Types_8h.html#a21">uint32</a> endIndex=MAX_UINT32)
<dl class="el"><dd class="mdescRight">Get the indices of a simplified OPEN polygon.  <a href="#a43"></a><br></dl><li>bool <a class="el" href="classGfxData.html#a44">douglasPeuckerPolygonFilter</a> (<a class="el" href="classStack.html">Stack</a> &amp;newPoly, <a class="el" href="Types_8h.html#a21">uint32</a> polyIndex, <a class="el" href="Types_8h.html#a21">uint32</a> epsilon) const 
<dl class="el"><dd class="mdescRight">A new polygon filtering algorithm, uses Douglas-Peucker.  <a href="#a44"></a><br></dl><li>bool <a class="el" href="classGfxData.html#a45">getMultiCoords</a> (multimap&lt; <a class="el" href="Types_8h.html#a21">uint32</a>, <a class="el" href="Types_8h.html#a21">uint32</a> &gt; &amp;selfTouchCoords) const 
<li>bool <a class="el" href="classGfxData.html#a46">closedPolygonFilter</a> (<a class="el" href="classStack.html">Stack</a> *newPoly, <a class="el" href="Types_8h.html#a21">uint32</a> polyIndex, <a class="el" href="Types_8h.html#a21">uint32</a> pMaxLatDist, <a class="el" href="Types_8h.html#a21">uint32</a> pMaxWayDist)
<dl class="el"><dd class="mdescRight">Get the indices of a simplified CLOSED polygon.  <a href="#a46"></a><br></dl><li>double <a class="el" href="classGfxData.html#a47">polygonArea</a> (<a class="el" href="Types_8h.html#a21">uint32</a> polyIndex) const 
<dl class="el"><dd class="mdescRight">Calculates the area of a given polygon.  <a href="#a47"></a><br></dl><li>bool <a class="el" href="classGfxData.html#a48">triangulatePolygon</a> (<a class="el" href="classStack.html">Stack</a> *stack, <a class="el" href="Types_8h.html#a21">uint32</a> polyIndex)
<dl class="el"><dd class="mdescRight">This method triangulates a given, simple polygon with N vertices into (N-2) triangles.  <a href="#a48"></a><br></dl><li>int <a class="el" href="classGfxData.html#a49">clockWise</a> (int polyIndex, int startIndex=0) const 
<dl class="el"><dd class="mdescRight">Function returns 0 for counterclockwise, 1 for clockwise and a negative number if there was a problem.  <a href="#a49"></a><br></dl><li><a class="el" href="classGfxDataFull.html">GfxDataFull</a> * <a class="el" href="classGfxData.html#a50">removeTooCloseCoordinates</a> (const <a class="el" href="Types_8h.html#a21">uint32</a> polygon, const <a class="el" href="Types_8h.html#a24">int64</a> minSqDist)
<dl class="el"><dd class="mdescRight">Another filtering algorithm, does not keep the convexity of the polygon.  <a href="#a50"></a><br></dl><li>bool <a class="el" href="classGfxData.html#a51">getTextPosition</a> (const <a class="el" href="classvector.html">vector</a>&lt; <a class="el" href="classMC2BoundingBox.html">MC2BoundingBox</a> &gt; &amp;objectBBoxes, <a class="el" href="Types_8h.html#a19">uint16</a> polygon, <a class="el" href="classGfxDataFull.html">GfxDataFull</a> *tmpGfx2, const <a class="el" href="classvector.html">vector</a>&lt; <a class="el" href="classGfxData.html">GfxData</a> * &gt; &amp;gfxTextArray) const 
<li>bool <a class="el" href="classGfxData.html#a52">closed</a> () const 
<li>virtual void <a class="el" href="classGfxData.html#a53">readPolygons</a> (<a class="el" href="Types_8h.html#a19">uint16</a> nbrPolygons, <a class="el" href="classDataBuffer.html">DataBuffer</a> &amp;dataBuffer, <a class="el" href="classGenericMap.html">GenericMap</a> *<a class="el" href="classmap.html">map</a>)=0
<dl class="el"><dd class="mdescRight">Reads the polygons from the dataBuffer.  <a href="#a53"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Inspect coordinates.</div></td></tr>
<tr><td colspan="2"><div class="groupText">Methods to get the coordinates of this <a class="el" href="classGfxData.html">GfxData</a>. <br><br></div></td></tr>
<ul>
<li><a class="el" href="Types_8h.html#a21">uint32</a> <a class="el" href="classGfxData.html#z491_0">getCoordinate</a> (<a class="el" href="Types_8h.html#a19">uint16</a> offset, <a class="el" href="classGfxData.html#w0">coordinate_type</a> &amp;lat, <a class="el" href="classGfxData.html#w0">coordinate_type</a> &amp;lon) const 
<dl class="el"><dd class="mdescRight">Get the coordinate at given offset.  <a href="#z491_0"></a><br></dl><li><a class="el" href="classGfxData.html#w0">coordinate_type</a> <a class="el" href="classGfxData.html#z491_1">getLastLat</a> (<a class="el" href="Types_8h.html#a19">uint16</a> p) const 
<dl class="el"><dd class="mdescRight">Get the latitude-part of the last coordinate.  <a href="#z491_1"></a><br></dl><li><a class="el" href="classGfxData.html#w0">coordinate_type</a> <a class="el" href="classGfxData.html#z491_2">getLastLon</a> (<a class="el" href="Types_8h.html#a19">uint16</a> p) const 
<dl class="el"><dd class="mdescRight">Get the longitude-part of the last coordinate.  <a href="#z491_2"></a><br></dl><li>virtual bool <a class="el" href="classGfxData.html#z491_3">getMC2BoundingBox</a> (<a class="el" href="classMC2BoundingBox.html">MC2BoundingBox</a> &amp;bb, <a class="el" href="Types_8h.html#a19">uint16</a> polygon=MAX_UINT16) const 
<dl class="el"><dd class="mdescRight">Get the bounding box for this GfxData.  <a href="#z491_3"></a><br></dl><li>virtual <a class="el" href="Types_8h.html#a27">float64</a> <a class="el" href="classGfxData.html#z491_4">getBBoxArea</a> () const 
<dl class="el"><dd class="mdescRight">Default implementation uses the getMC2BoundingBix-methods.  <a href="#z491_4"></a><br></dl><li>virtual <a class="el" href="Types_8h.html#a23">uint64</a> <a class="el" href="classGfxData.html#z491_5">getBBoxArea_mc2</a> () const 
<li>virtual bool <a class="el" href="classGfxData.html#z491_6">insideBBox</a> (<a class="el" href="Types_8h.html#a22">int32</a> lat, <a class="el" href="Types_8h.html#a22">int32</a> lon) const 
<li>bool <a class="el" href="classGfxData.html#z491_7">getRandomCoordinateInside</a> (<a class="el" href="classGfxData.html#w0">coordinate_type</a> &amp;lat, <a class="el" href="classGfxData.html#w0">coordinate_type</a> &amp;lon, <a class="el" href="Types_8h.html#a21">uint32</a> maxTries=1000) const 
<dl class="el"><dd class="mdescRight">Get a random coordinate that is inside any of the polygons in the GfxData.  <a href="#z491_7"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Math utility.</div></td></tr>
<tr><td colspan="2"><div class="groupText">Inspect graphical properties of this <a class="el" href="classGfxData.html">GfxData</a>. <br><br></div></td></tr>
<ul>
<li><a class="el" href="Types_8h.html#a19">uint16</a> <a class="el" href="classGfxData.html#z493_0">getAverageNbrMaxTries</a> (const <a class="el" href="Types_8h.html#a19">uint16</a> polygon) const 
<dl class="el"><dd class="mdescRight">This fucntion may be used as a a help in method getRandomCoordinateInside.  <a href="#z493_0"></a><br></dl><li>int <a class="el" href="classGfxData.html#z493_1">insidePolygon</a> (<a class="el" href="classGfxData.html#w0">coordinate_type</a> lat, <a class="el" href="classGfxData.html#w0">coordinate_type</a> lon, <a class="el" href="Types_8h.html#a19">uint16</a> usePolygon=MAX_UINT16) const 
<dl class="el"><dd class="mdescRight">Determins where a specified point is located relative this polygon (inside, outside or on the boundry).  <a href="#z493_1"></a><br></dl><li>int <a class="el" href="classGfxData.html#z493_2">insidePolygon</a> (<a class="el" href="classMC2Coordinate.html">MC2Coordinate</a> coord, <a class="el" href="Types_8h.html#a19">uint16</a> usePolygon=MAX_UINT16) const 
<li>int <a class="el" href="classGfxData.html#z493_3">nbrCornersInsidePolygon</a> (const <a class="el" href="classMC2BoundingBox.html">MC2BoundingBox</a> &amp;bbox, int maxCorners=4, <a class="el" href="Types_8h.html#a19">uint16</a> usePolygon=MAX_UINT16) const 
<dl class="el"><dd class="mdescRight">Calculates how many of the corners of the bounding box that are inside or at the boundry of the polygon.  <a href="#z493_3"></a><br></dl><li><a class="el" href="Types_8h.html#a23">uint64</a> <a class="el" href="classGfxData.html#z493_4">squareDistWithOffsetToLine_mc2</a> (<a class="el" href="classGfxData.html#w0">coordinate_type</a> lat, <a class="el" href="classGfxData.html#w0">coordinate_type</a> lon, <a class="el" href="Types_8h.html#a19">uint16</a> &amp;closestPolygon, <a class="el" href="Types_8h.html#a21">uint32</a> &amp;closestI, <a class="el" href="Types_8h.html#a27">float64</a> &amp;closestT, <a class="el" href="Types_8h.html#a19">uint16</a> usePolygon=MAX_UINT16) const 
<dl class="el"><dd class="mdescRight">A better name would be squaredDistToBoundry.  <a href="#z493_4"></a><br></dl><li><a class="el" href="Types_8h.html#a23">uint64</a> <a class="el" href="classGfxData.html#z493_5">squareDistWithOffsetToLine</a> (<a class="el" href="classGfxData.html#w0">coordinate_type</a> lat, <a class="el" href="classGfxData.html#w0">coordinate_type</a> lon, <a class="el" href="Types_8h.html#a19">uint16</a> &amp;cloestPoly, <a class="el" href="Types_8h.html#a21">uint32</a> &amp;closestI, <a class="el" href="Types_8h.html#a27">float64</a> &amp;closestT, <a class="el" href="Types_8h.html#a19">uint16</a> usePolygon=MAX_UINT16) const 
<dl class="el"><dd class="mdescRight">A better name would be squaredDistToBoundry.  <a href="#z493_5"></a><br></dl><li><a class="el" href="Types_8h.html#a23">uint64</a> <a class="el" href="classGfxData.html#z493_6">squareDistToLine_mc2</a> (<a class="el" href="classGfxData.html#w0">coordinate_type</a> lat, <a class="el" href="classGfxData.html#w0">coordinate_type</a> lon, <a class="el" href="Types_8h.html#a19">uint16</a> usePolygon=MAX_UINT16) const 
<dl class="el"><dd class="mdescRight">A better name would be squaredDistToBoundry.  <a href="#z493_6"></a><br></dl><li><a class="el" href="Types_8h.html#a23">uint64</a> <a class="el" href="classGfxData.html#z493_7">squareDistToLine</a> (<a class="el" href="classGfxData.html#w0">coordinate_type</a> lat, <a class="el" href="classGfxData.html#w0">coordinate_type</a> lon, <a class="el" href="Types_8h.html#a19">uint16</a> usePolygon=MAX_UINT16) const 
<dl class="el"><dd class="mdescRight">A better name would be squaredDistToBoundry.  <a href="#z493_7"></a><br></dl><li><a class="el" href="Types_8h.html#a23">uint64</a> <a class="el" href="classGfxData.html#z493_8">squareDistTo</a> (<a class="el" href="classGfxData.html#w0">coordinate_type</a> lat, <a class="el" href="classGfxData.html#w0">coordinate_type</a> lon, <a class="el" href="Types_8h.html#a19">uint16</a> usePolygon=MAX_UINT16) const 
<dl class="el"><dd class="mdescRight">This function is the same as the above with the differance that points inside (if the polygon is closed) have their distance set to 0.  <a href="#z493_8"></a><br></dl><li><a class="el" href="Types_8h.html#a23">uint64</a> <a class="el" href="classGfxData.html#z493_9">minSquareDistTo</a> (const <a class="el" href="classGfxData.html">GfxData</a> *otherGfx) const 
<dl class="el"><dd class="mdescRight">This function is the same as the above with the differance that points inside (if the polygon is closed) have their distance set to 0.  <a href="#z493_9"></a><br></dl><li><a class="el" href="Types_8h.html#a24">int64</a> <a class="el" href="classGfxData.html#z493_10">signedSquareDistTo</a> (<a class="el" href="classGfxData.html#w0">coordinate_type</a> lat, <a class="el" href="classGfxData.html#w0">coordinate_type</a> lon, <a class="el" href="Types_8h.html#a19">uint16</a> usePolygon=MAX_UINT16) const 
<dl class="el"><dd class="mdescRight">As squareDistToLine with the differance that points on the inside of a closed polygon will have their distance counted as negative.  <a href="#z493_10"></a><br></dl><li><a class="el" href="Types_8h.html#a24">int64</a> <a class="el" href="classGfxData.html#z493_11">signedSquareDistTo_mc2</a> (<a class="el" href="classGfxData.html#w0">coordinate_type</a> lat, <a class="el" href="classGfxData.html#w0">coordinate_type</a> lon, <a class="el" href="Types_8h.html#a19">uint16</a> usePolygon=MAX_UINT16) const 
<li><a class="el" href="Types_8h.html#a27">float64</a> <a class="el" href="classGfxData.html#z493_12">getAngle</a> (<a class="el" href="Types_8h.html#a19">uint16</a> offset) const 
<dl class="el"><dd class="mdescRight">Get the angle at given offset.  <a href="#z493_12"></a><br></dl><li><a class="el" href="Types_8h.html#a19">uint16</a> <a class="el" href="classGfxData.html#z493_13">getOffset</a> (<a class="el" href="Types_8h.html#a22">int32</a> lat, <a class="el" href="Types_8h.html#a22">int32</a> lon, <a class="el" href="Types_8h.html#a22">int32</a> &amp;latOnPoly, <a class="el" href="Types_8h.html#a22">int32</a> &amp;lonOnPoly) const 
</ul>
<h2>Static Public Member Functions</h2>
<ul>
<li><a class="el" href="classGfxDataFull.html">GfxDataFull</a> * <a class="el" href="classGfxData.html#e0">createNewGfxData</a> (<a class="el" href="classGenericMap.html">GenericMap</a> *theMap, bool createNewPolygon=false)
<li><a class="el" href="classGfxData.html">GfxData</a> * <a class="el" href="classGfxData.html#e1">createNewGfxData</a> (<a class="el" href="classGenericMap.html">GenericMap</a> *theMap, const <a class="el" href="classMC2BoundingBox.html">MC2BoundingBox</a> *bbox)
<li><a class="el" href="classGfxData.html">GfxData</a> * <a class="el" href="classGfxData.html#e2">createNewGfxData</a> (<a class="el" href="classGenericMap.html">GenericMap</a> *theMap, const <a class="el" href="classGfxData.html#w0">coordinate_type</a> *firstLat, const <a class="el" href="classGfxData.html#w0">coordinate_type</a> *firstLon, <a class="el" href="Types_8h.html#a19">uint16</a> nbrCoords, bool closed)
<li><a class="el" href="classGfxData.html">GfxData</a> * <a class="el" href="classGfxData.html#e3">createNewGfxData</a> (<a class="el" href="classGenericMap.html">GenericMap</a> *theMap, const <a class="el" href="classGfxData.html">GfxData</a> *src)
<li><a class="el" href="classGfxData.html">GfxData</a> * <a class="el" href="classGfxData.html#e4">getArcApproximation</a> (<a class="el" href="Types_8h.html#a22">int32</a> lat, <a class="el" href="Types_8h.html#a22">int32</a> lon, int startAngle, int stopAngle, int outerRadius, int innerRadius=0, <a class="el" href="Types_8h.html#a27">float64</a> angleIncrement=0.2)
<dl class="el"><dd class="mdescRight">Create a GfxData that is an approximation of an arc or circle sector.  <a href="#e4"></a><br></dl></ul>
<h2>Protected Types</h2>
<ul>
<li>typedef set&lt; pair&lt; <a class="el" href="Types_8h.html#a21">uint32</a>,<br>
 <a class="el" href="Types_8h.html#a21">uint32</a> &gt; &gt; <a class="el" href="classGfxData.html#x0">idxSet_t</a>
<li>typedef <a class="el" href="classmap.html">map</a>&lt; <a class="el" href="classMC2Coordinate.html">MC2Coordinate</a>,<br>
 <a class="el" href="classGfxData.html#x0">idxSet_t</a> &gt; <a class="el" href="classGfxData.html#x1">coordMap_t</a>
</ul>
<h2>Protected Member Functions</h2>
<ul>
<li>double <a class="el" href="classGfxData.html#b0">distToTriangleSide</a> (<a class="el" href="Types_8h.html#a21">uint32</a> polyIndex, <a class="el" href="Types_8h.html#a21">uint32</a> testIndex, <a class="el" href="Types_8h.html#a21">uint32</a> prevIndex, <a class="el" href="Types_8h.html#a21">uint32</a> currIndex, <a class="el" href="Types_8h.html#a21">uint32</a> nextIndex)
<dl class="el"><dd class="mdescRight">Method used in triangulatePolygon method.  <a href="#b0"></a><br></dl><li>void <a class="el" href="classGfxData.html#b1">removePolygonVertex</a> (<a class="el" href="Types_8h.html#a22">int32</a> polyVec[], <a class="el" href="Types_8h.html#a21">uint32</a> nbrCoordInVec, <a class="el" href="Types_8h.html#a21">uint32</a> VertexPos)
<dl class="el"><dd class="mdescRight">Method used in triangulatePolygon method.  <a href="#b1"></a><br></dl><li><a class="el" href="Types_8h.html#a21">uint32</a> <a class="el" href="classGfxData.html#b2">nbrCoordInSplittedPolygon</a> (<a class="el" href="Types_8h.html#a22">int32</a> polyVec[])
<dl class="el"><dd class="mdescRight">Method used in triangulatePolygon method.  <a href="#b2"></a><br></dl><li>void <a class="el" href="classGfxData.html#b3">splitPolygon</a> (<a class="el" href="Types_8h.html#a22">int32</a> polyVec[], <a class="el" href="Types_8h.html#a21">uint32</a> nbrCoordInPoly, <a class="el" href="Types_8h.html#a21">uint32</a> startIndexPos, <a class="el" href="Types_8h.html#a21">uint32</a> stopIndexPos)
<dl class="el"><dd class="mdescRight">Method used in triangulatePolygon method.  <a href="#b3"></a><br></dl></ul>
<h2>Static Protected Member Functions</h2>
<ul>
<li>void <a class="el" href="classGfxData.html#f0">fillCoordMap</a> (const <a class="el" href="classGfxData.html">GfxData</a> *gfx, <a class="el" href="Types_8h.html#a21">uint32</a> poly, <a class="el" href="classmap.html">coordMap_t</a> &amp;gfxCoords, <a class="el" href="Types_8h.html#a21">uint32</a> polyIdxToStore)
<dl class="el"><dd class="mdescRight">Help method to i.e.  <a href="#f0"></a><br></dl></ul>
<h2>Private Member Functions</h2>
<ul>
<li>bool <a class="el" href="classGfxData.html#d0">checkConcaveCorner</a> (<a class="el" href="Types_8h.html#a19">uint16</a> polyIndex, <a class="el" href="Types_8h.html#a22">int32</a> currentIndex)
<dl class="el"><dd class="mdescRight">Help method for closedPolygonFilter.  <a href="#d0"></a><br></dl><li><a class="el" href="Types_8h.html#a27">float64</a> <a class="el" href="classGfxData.html#d1">getAngleNoCoslat</a> (ConvexHullNotice *notice1, ConvexHullNotice *notice2, <a class="el" href="Types_8h.html#a19">uint16</a> polygon)
<dl class="el"><dd class="mdescRight">Help method for getConvexHull.  <a href="#d1"></a><br></dl><li>bool <a class="el" href="classGfxData.html#d2">getBBox</a> (<a class="el" href="classGfxData.html#w0">coordinate_type</a> &amp;minLat, <a class="el" href="classGfxData.html#w0">coordinate_type</a> &amp;maxLat, <a class="el" href="classGfxData.html#w0">coordinate_type</a> &amp;minLon, <a class="el" href="classGfxData.html#w0">coordinate_type</a> &amp;maxLon) const 
<dl class="el"><dd class="mdescRight">Internal method for getting boundingbox.  <a href="#d2"></a><br></dl><li>int <a class="el" href="classGfxData.html#d3">getSegment</a> (<a class="el" href="Types_8h.html#a19">uint16</a> offset) const 
<dl class="el"><dd class="mdescRight">Returns the number of the polygon where the offset point is only supports the use of one polygon.  <a href="#d3"></a><br></dl><li><a class="el" href="Types_8h.html#a22">int32</a> <a class="el" href="classGfxData.html#d4">orientation</a> (<a class="el" href="Types_8h.html#a21">uint32</a> polyIndex, <a class="el" href="Types_8h.html#a21">uint32</a> x, <a class="el" href="Types_8h.html#a21">uint32</a> y, <a class="el" href="Types_8h.html#a21">uint32</a> z) const 
<dl class="el"><dd class="mdescRight">Get the orientation of three vertices x, y and z i a polygon.  <a href="#d4"></a><br></dl><li><a class="el" href="Types_8h.html#a22">int32</a> <a class="el" href="classGfxData.html#d5">orientation</a> (<a class="el" href="Types_8h.html#a22">int32</a> lat1, <a class="el" href="Types_8h.html#a22">int32</a> lon1, <a class="el" href="Types_8h.html#a22">int32</a> lat2, <a class="el" href="Types_8h.html#a22">int32</a> lon2, <a class="el" href="Types_8h.html#a22">int32</a> lat3, <a class="el" href="Types_8h.html#a22">int32</a> lon3) const 
<li>bool <a class="el" href="classGfxData.html#d6">segmentIntersect</a> (<a class="el" href="Types_8h.html#a21">uint32</a> polyIndex, <a class="el" href="Types_8h.html#a21">uint32</a> p1, <a class="el" href="Types_8h.html#a21">uint32</a> p2, <a class="el" href="Types_8h.html#a21">uint32</a> q1, <a class="el" href="Types_8h.html#a21">uint32</a> q2) const 
<dl class="el"><dd class="mdescRight">Determines if two segments (p1,p2) and (q1,q2) intersect at any point.  <a href="#d6"></a><br></dl><li>double <a class="el" href="classGfxData.html#d7">crossDistance</a> (<a class="el" href="Types_8h.html#a21">uint32</a> polyIndex, <a class="el" href="Types_8h.html#a21">uint32</a> k, <a class="el" href="Types_8h.html#a21">uint32</a> a, <a class="el" href="Types_8h.html#a21">uint32</a> b)
<dl class="el"><dd class="mdescRight">Function used in method openPolygonFilter.  <a href="#d7"></a><br></dl><li>double <a class="el" href="classGfxData.html#d8">maxCrossDistance</a> (<a class="el" href="Types_8h.html#a21">uint32</a> polyIndex, <a class="el" href="Types_8h.html#a21">uint32</a> a, <a class="el" href="Types_8h.html#a21">uint32</a> b)
<dl class="el"><dd class="mdescRight">Function used in method openPolygonFilter.  <a href="#d8"></a><br></dl><li><a class="el" href="Types_8h.html#a21">uint32</a> <a class="el" href="classGfxData.html#d9">getBestIndexBetween</a> (<a class="el" href="Types_8h.html#a19">uint16</a> polyIndex, <a class="el" href="Types_8h.html#a21">uint32</a> a, <a class="el" href="Types_8h.html#a21">uint32</a> b)
<dl class="el"><dd class="mdescRight">Help method to the filtering methods.  <a href="#d9"></a><br></dl><li>double <a class="el" href="classGfxData.html#d10">triangleArea</a> (double d1, double d2, double d3) const 
<dl class="el"><dd class="mdescRight">Calculates the are of a triangle with given sides, using Heron's formula.  <a href="#d10"></a><br></dl></ul>
<tr><td colspan="2"><div class="groupHeader">Simplify polygon.</div></td></tr>
<tr><td colspan="2"><div class="groupText">These methods are used by the getSimplifiedPolygon-method. <br><br></div></td></tr>
<ul>
<li>bool <a class="el" href="classGfxData.html#z495_0">simplifyPoly</a> (<a class="el" href="classStack.html">Stack</a> *newPoly, <a class="el" href="Types_8h.html#a21">uint32</a> polyIndex, <a class="el" href="Types_8h.html#a24">int64</a> maxSqist, <a class="el" href="Types_8h.html#a24">int64</a> minSqDist) const 
<dl class="el"><dd class="mdescRight">Calculates a simplified hull.  <a href="#z495_0"></a><br></dl><li>void <a class="el" href="classGfxData.html#z495_1">findBoundaryLoops2</a> (<a class="el" href="classStack.html">Stack</a> *newPoly, <a class="el" href="Types_8h.html#a21">uint32</a> polyIndex) const 
<dl class="el"><dd class="mdescRight">Finds and removes ALL the loops on the boundary of a filtered polygon.  <a href="#z495_1"></a><br></dl><li><a class="el" href="Types_8h.html#a21">uint32</a> <a class="el" href="classGfxData.html#z495_2">stepIndex</a> (int step, <a class="el" href="Types_8h.html#a22">int32</a> index, <a class="el" href="Types_8h.html#a22">int32</a> nbrCoord) const 
<dl class="el"><dd class="mdescRight">Calculates the next index in the polygon vector.  <a href="#z495_2"></a><br></dl><li><a class="el" href="Types_8h.html#a21">uint32</a> <a class="el" href="classGfxData.html#z495_3">getPointOnConvexHull</a> (int polyIndex) const 
<dl class="el"><dd class="mdescRight">Finding the point in the polygon with the highest y-coordinate (latitude).  <a href="#z495_3"></a><br></dl><li>int <a class="el" href="classGfxData.html#z495_4">clockWiseByArea</a> (<a class="el" href="Types_8h.html#a21">uint32</a> polyIndex) const 
<dl class="el"><dd class="mdescRight">Does the same as the function <a class="el" href="classGfxData.html#a49">GfxData::clockWise</a>, without using parameter startIndex.  <a href="#z495_4"></a><br></dl><li><a class="el" href="Types_8h.html#a24">int64</a> <a class="el" href="classGfxData.html#z495_5">dist</a> (<a class="el" href="Types_8h.html#a22">int32</a> polyIndex, <a class="el" href="Types_8h.html#a22">int32</a> first, <a class="el" href="Types_8h.html#a22">int32</a> second) const 
<dl class="el"><dd class="mdescRight">Get the distance between two points.  <a href="#z495_5"></a><br></dl><li><a class="el" href="Types_8h.html#a24">int64</a> <a class="el" href="classGfxData.html#z495_6">dist</a> (<a class="el" href="classMC2Coordinate.html">const_iterator</a> polyIter, <a class="el" href="Types_8h.html#a22">int32</a> first, <a class="el" href="Types_8h.html#a22">int32</a> second) const 
<dl class="el"><dd class="mdescRight">Get the distance between two points.  <a href="#z495_6"></a><br></dl></ul>
<h2>Friends</h2>
<ul>
<li>class <a class="el" href="classGfxData.html#n0">SimulateRouteWindow</a>
<li>class <a class="el" href="classGfxData.html#n1">MESimulateRouteWindow</a>
<li>class <a class="el" href="classGfxData.html#n2">GMSPolyUtility</a>
</ul>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Contains all graphical information about one item. 
<p>
All coordinates are stored as an int32 in parts of (2*pi/2^32) &lt;it&gt;Observe that this means that it <b>not</b> is possible to treat them as planear coordinates!&lt;/it&gt;<p>
It is important that alla comparisons being done with longitudes consider that this variable is cyclic. If you want to do <code>lon1 &lt; lon2</code> You should write <code>(int32)(lon1 - lon2) &lt; 0</code> With latitudes this problem is of no concern as latitudes doesn't loop. In all code it is assumed that no polygon covers more than 180 longitudinal degrees. 
<p>

<p>
Definition at line <a class="el" href="GfxData_8h-source.html#l00135">135</a> of file <a class="el" href="GfxData_8h-source.html">GfxData.h</a>.<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="w3" doxytag="GfxData::const_filter_iterator"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef <a class="el" href="classGfxDataFilterIterator.html">GfxDataFilterIterator</a> <a class="el" href="classGfxDataFilterIterator.html">GfxData::const_filter_iterator</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The filter iterator. Operates on coordinates, not polygons. 
<p>

<p>
Definition at line <a class="el" href="GfxData_8h-source.html#l00208">208</a> of file <a class="el" href="GfxData_8h-source.html">GfxData.h</a>.    </td>
  </tr>
</table>
<a class="anchor" name="w2" doxytag="GfxData::const_iterator"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef const <a class="el" href="classMC2Coordinate.html">MC2Coordinate</a>* <a class="el" href="classMC2Coordinate.html">GfxData::const_iterator</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Ordinary const iterator for all coordinates in a polygon. 
<p>

<p>
Definition at line <a class="el" href="GfxData_8h-source.html#l00143">143</a> of file <a class="el" href="GfxData_8h-source.html">GfxData.h</a>.
<p>
Referenced by <a class="el" href="OldMapFilter_8h-source.html#l00459">OldMapFilter::filterSegment()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="w0" doxytag="GfxData::coordinate_type"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef <a class="el" href="Types_8h.html#a22">int32</a> <a class="el" href="classGfxData.html#w0">GfxData::coordinate_type</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Numeric type of coordinates. 
<p>

<p>
Definition at line <a class="el" href="GfxData_8h-source.html#l00138">138</a> of file <a class="el" href="GfxData_8h-source.html">GfxData.h</a>.    </td>
  </tr>
</table>
<a class="anchor" name="x1" doxytag="GfxData::coordMap_t"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef <a class="el" href="classmap.html">map</a>&lt; <a class="el" href="classMC2Coordinate.html">MC2Coordinate</a>, <a class="el" href="classGfxData.html#x0">idxSet_t</a> &gt; <a class="el" href="classmap.html">GfxData::coordMap_t</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="GfxData_8h-source.html#l01128">1128</a> of file <a class="el" href="GfxData_8h-source.html">GfxData.h</a>.    </td>
  </tr>
</table>
<a class="anchor" name="x0" doxytag="GfxData::idxSet_t"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef set&lt; pair&lt;<a class="el" href="Types_8h.html#a21">uint32</a>,<a class="el" href="Types_8h.html#a21">uint32</a>&gt; &gt; <a class="el" href="classGfxData.html#x0">GfxData::idxSet_t</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="GfxData_8h-source.html#l01127">1127</a> of file <a class="el" href="GfxData_8h-source.html">GfxData.h</a>.    </td>
  </tr>
</table>
<a class="anchor" name="w1" doxytag="GfxData::iterator"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef <a class="el" href="classMC2Coordinate.html">MC2Coordinate</a>* <a class="el" href="classMC2Coordinate.html">GfxData::iterator</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Ordinary iterator for all coordinates in a polygon. 
<p>

<p>
Definition at line <a class="el" href="GfxData_8h-source.html#l00141">141</a> of file <a class="el" href="GfxData_8h-source.html">GfxData.h</a>.    </td>
  </tr>
</table>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="w9" doxytag="GfxData::gfxdata_t"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">enum <a class="el" href="classGfxData.html#w9">GfxData::gfxdata_t</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="w9w4" doxytag="gfxDataFull"></a>gfxDataFull</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="w9w5" doxytag="gfxDataSingleSmallPoly"></a>gfxDataSingleSmallPoly</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="w9w6" doxytag="gfxDataSingleLine"></a>gfxDataSingleLine</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="w9w7" doxytag="gfxDataSinglePoint"></a>gfxDataSinglePoint</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="w9w8" doxytag="gfxDataMultiplePoints"></a>gfxDataMultiplePoints</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

<p>
Definition at line <a class="el" href="GfxData_8h-source.html#l00311">311</a> of file <a class="el" href="GfxData_8h-source.html">GfxData.h</a>.    </td>
  </tr>
</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="a0" doxytag="GfxData::GfxData"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">GfxData::GfxData           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates an empty GfxData. 
<p>

<p>
Definition at line <a class="el" href="GfxData_8h-source.html#l00164">164</a> of file <a class="el" href="GfxData_8h-source.html">GfxData.h</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="GfxData::~GfxData"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual GfxData::~<a class="el" href="classGfxData.html">GfxData</a>           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Since this class have to be abstract, we need a proper destructor. 
<p>

<p>
Definition at line <a class="el" href="GfxData_8h-source.html#l00171">171</a> of file <a class="el" href="GfxData_8h-source.html">GfxData.h</a>.    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a12" doxytag="GfxData::beginFilteredPoly"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classGfxDataFilterIterator.html">const_filter_iterator</a> GfxData::beginFilteredPoly           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>polyIdx</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a17">uint8</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>filterLevel</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Begin iterator for polygon polyIdx. 
<p>

<p>
Definition at line <a class="el" href="GfxData_8h-source.html#l00212">212</a> of file <a class="el" href="GfxData_8h-source.html">GfxData.h</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a23" doxytag="GfxData::calcPolyLength"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a27">float64</a> GfxData::calcPolyLength           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>polyIdx</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculates the length of polygon <code>polyIndex</code>. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="d0" doxytag="GfxData::checkConcaveCorner"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool GfxData::checkConcaveCorner           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>polyIndex</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a22">int32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>currentIndex</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [private]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Help method for closedPolygonFilter. 
<p>
Will check if the corner on the polygon is concave. Needs at least three coordinates in the polygon. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>polyIndex</em>&nbsp;</td><td>The polygon index. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>currentIndex</em>&nbsp;</td><td>The coordinate index for the corner. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>If the corner is concave or not. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a49" doxytag="GfxData::clockWise"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int GfxData::clockWise           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>polyIndex</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>startIndex</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Function returns 0 for counterclockwise, 1 for clockwise and a negative number if there was a problem. 
<p>
Problems could be a polygon with no area, or a polygon with less than 3 points. Indata is the index of the polygon to be investigated and one point on the convex hull. This can be found with GfxData::pointOnConvexHull.<p>
Polygon must be checked first so that not two sides of the polygon intersect. Nor can two points be equal, and no sequence of ABC where A is on the line BC. On that kind of behaviour, function might(!) also return negative value.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>polyIndex</em>&nbsp;</td><td>The index of the polygon to find the direction for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startIndex</em>&nbsp;</td><td>The index to start looking at. This parameter is DEPRECATED, is not used inside the method! </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>1 for clockwise and 0 for counter clockwise. -1 is returned upon error. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z495_4" doxytag="GfxData::clockWiseByArea"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int GfxData::clockWiseByArea           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>polyIndex</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [private]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Does the same as the function <a class="el" href="classGfxData.html#a49">GfxData::clockWise</a>, without using parameter startIndex. 
<p>
The area is calculated with <a class="el" href="classGfxData.html#a47">GfxData::polygonArea</a>, and the area will be positive if the orientation is clockwise, negative otherwise.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>polyIndex</em>&nbsp;</td><td>The index of the polygon to find the direction for. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>1 for clockwise and 0 for counter clockwise. -1 is returned upon error. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a52" doxytag="GfxData::closed"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool GfxData::closed           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="GfxData_8h-source.html#l01035">1035</a> of file <a class="el" href="GfxData_8h-source.html">GfxData.h</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a46" doxytag="GfxData::closedPolygonFilter"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool GfxData::closedPolygonFilter           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classStack.html">Stack</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>newPoly</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>polyIndex</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>pMaxLatDist</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>pMaxWayDist</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the indices of a simplified CLOSED polygon. 
<p>
These indices are inserted into the preallocated stack that are given as parameter. All convex vertices are kept ( vertices which make the polygon smaller if they are removed ) so that no polygon part is "cut" Loops may be created in the simplified polygon, so that triangulation is impossible.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stack</em>&nbsp;</td><td>This stack will be filled with the indices of the coordinates to include in the simplified polygon. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>polyIndex</em>&nbsp;</td><td>The index of the polygon within this GfxData to simplify.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pMaxLatDist</em>&nbsp;</td><td>The maximum deviation in meters of the given points from a new line. Example: If we want to make a new line from point 1 to point 4 and therefore skip points 2 and 3, the perpendicular distance to points 2 and 3 from the wanted line must be smaller than maxLatDist.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pMaxWayDist</em>&nbsp;</td><td>The maximum distance in meters between two coordinates. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True if the stack is filled with indices, false otherwise. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a33" doxytag="GfxData::convexPolygon"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool GfxData::convexPolygon           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>polygon</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Finds out if a given simple polygon is convex, i.e all lines drawn between any pair of nodes are entirely inside of or on the boundary of the polygon. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>polyIndex</em>&nbsp;</td><td>The index for the polygon used. Polygon is assumed to be CLOCKWISE oriented!</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True if polygon is convex, false otherwise </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a30" doxytag="GfxData::createFromDataBuffer"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void GfxData::createFromDataBuffer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classDataBuffer.html">DataBuffer</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>dataBuffer</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a40" doxytag="GfxData::createNewConvexHull"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classGfxData.html">GfxData</a>* GfxData::createNewConvexHull           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculates the convex hull for all the polygons of the GfxData and returns a new GfxData created by GfxData::createGfxData(NULL). 
<p>
Uses the function <a class="el" href="classGfxData.html#a39">getConvexHull(Stack* stack, uint16 polygon)</a> internally which seems to work. <dl compact><dt><b>Returns:</b></dt><dd>New GfxData or NULL if failure. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="e3" doxytag="GfxData::createNewGfxData"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classGfxData.html">GfxData</a>* GfxData::createNewGfxData           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classGenericMap.html">GenericMap</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>theMap</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classGfxData.html">GfxData</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>src</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="e2" doxytag="GfxData::createNewGfxData"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classGfxData.html">GfxData</a>* GfxData::createNewGfxData           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classGenericMap.html">GenericMap</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>theMap</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classGfxData.html#w0">coordinate_type</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>firstLat</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classGfxData.html#w0">coordinate_type</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>firstLon</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>nbrCoords</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>closed</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="e1" doxytag="GfxData::createNewGfxData"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classGfxData.html">GfxData</a>* GfxData::createNewGfxData           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classGenericMap.html">GenericMap</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>theMap</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classMC2BoundingBox.html">MC2BoundingBox</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>bbox</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="e0" doxytag="GfxData::createNewGfxData"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classGfxDataFull.html">GfxDataFull</a>* GfxData::createNewGfxData           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classGenericMap.html">GenericMap</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>theMap</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>createNewPolygon</em> = <code>false</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Referenced by <a class="el" href="MapModuleNotice_8h-source.html#l00219">MapModuleNotice::setGfxData()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="d7" doxytag="GfxData::crossDistance"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double GfxData::crossDistance           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>polyIndex</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>k</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>b</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [private]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Function used in method openPolygonFilter. 
<p>
Determines the perpendicular distance from point k to the line containing points a and b.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>polyIndex</em>&nbsp;</td><td>Index of the polygon used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k</em>&nbsp;</td><td>Vertex in the open polygon </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>Vertex in the open polygon. Located before k. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Vertex in the open polygon. Located after k. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The distance. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z495_6" doxytag="GfxData::dist"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a24">int64</a> GfxData::dist           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classMC2Coordinate.html">const_iterator</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>polyIter</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a22">int32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a22">int32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>second</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [private]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the distance between two points. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>polyIter</em>&nbsp;</td><td>The iterator of the polygon to look at. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The index of the first coordinate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>secind</em>&nbsp;</td><td>The index of the second coordinate. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The distance between first and second. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z495_5" doxytag="GfxData::dist"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a24">int64</a> GfxData::dist           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a22">int32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>polyIndex</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a22">int32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a22">int32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>second</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [private]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the distance between two points. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>polyIndex</em>&nbsp;</td><td>The index of the polygon to look at. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The index of the first coordinate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>secind</em>&nbsp;</td><td>The index of the second coordinate. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The distance between first and second. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="b0" doxytag="GfxData::distToTriangleSide"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double GfxData::distToTriangleSide           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>polyIndex</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>testIndex</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>prevIndex</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>currIndex</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>nextIndex</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Method used in triangulatePolygon method. 
<p>
The triangle T formed by vertices prevIndex, currIndex and nextIndex in the polygon P (with number polyIndex) is considered. IF vertex testIndex in P is inside T, a measure of the perpendicular distance from testIndex to the line between prevIndex and nextIndex is determined.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>polyIndex</em>&nbsp;</td><td>The index of the polygon used to triangulate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>testIndex</em>&nbsp;</td><td>Vertex to test if it is inside a triangle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prevIndex</em>&nbsp;</td><td>One vertex forming triangle P. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>currIndex</em>&nbsp;</td><td>Second vertex forming triangle P. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nextIndex</em>&nbsp;</td><td>Third vertex forming triangle P.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>IF testIndex is in P: Area of P, which is proportional to the perpendicular distance searched for. -1 otherwise. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a44" doxytag="GfxData::douglasPeuckerPolygonFilter"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool GfxData::douglasPeuckerPolygonFilter           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classStack.html">Stack</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>newPoly</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>polyIndex</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>epsilon</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A new polygon filtering algorithm, uses Douglas-Peucker. 
<p>
Should be faster than openPolygonFilter when heavy filtering is done (lots of coords removed).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newPoly</em>&nbsp;</td><td>Will be filled with the indices of the coordinates of the simplified polygon. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>polyIndex</em>&nbsp;</td><td>The index of the polygon to filter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>epsilon</em>&nbsp;</td><td>The maximum deviation that the simplified polygon may have from the original one (in meters). </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True if the resulting poly is more than just a point. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="GfxData::endFilteredPoly"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classGfxDataFilterIterator.html">const_filter_iterator</a> GfxData::endFilteredPoly           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>polyIdx</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a17">uint8</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>filterLevel</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
End iterator for polygon polyIdx. 
<p>
<dl compact><dt><b>Warning:</b></dt><dd>! Relative complicated to create so only do it once per loop. </dd></dl>

<p>
Definition at line <a class="el" href="GfxData_8h-source.html#l00224">224</a> of file <a class="el" href="GfxData_8h-source.html">GfxData.h</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a38" doxytag="GfxData::equals"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool GfxData::equals           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classGfxData.html">GfxData</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>otherData</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Find out if this GfxData is equal to another GfxData. 
<p>
NOTE: Both GfxData must have the same orientation.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>otherData</em>&nbsp;</td><td>The other GfxData to be compared to this GfxData.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True if GfxData and otherData are equivalent, false otherwise. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a37" doxytag="GfxData::equals"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool GfxData::equals           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>thisPolygon</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>thisCoord</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classGfxData.html">GfxData</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>otherGfx</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>otherPolygon</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>otherCoord</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>factor</em> = <code>1</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Find out if this GfxData is equal to another one. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="f0" doxytag="GfxData::fillCoordMap"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void GfxData::fillCoordMap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classGfxData.html">GfxData</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>gfx</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>poly</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classmap.html">coordMap_t</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>gfxCoords</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>polyIdxToStore</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static, protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Help method to i.e. 
<p>
mergeTwoPolygons. Fill a coordinate map&lt;&gt; with coordinates info from a gfx data. The map is filled with <a class="el" href="classMC2Coordinate.html">MC2Coordinate</a> as key and a set of &lt;poyIdx, coordIdx&gt; as value.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gfx</em>&nbsp;</td><td>The gfx to fill into gfxCoords. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>poly</em>&nbsp;</td><td>Which polygon of gfx is wanted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gfxCoords</em>&nbsp;</td><td>The coordinate map&lt;&gt; to fill with info. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>polyIdxToStore</em>&nbsp;</td><td>Which polyIdx to use for info from this gfx. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z495_1" doxytag="GfxData::findBoundaryLoops2"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void GfxData::findBoundaryLoops2           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classStack.html">Stack</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>newPoly</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>polyIndex</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [private]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Finds and removes ALL the loops on the boundary of a filtered polygon. 
<p>
These loops cause the triangulation process to terminate. EXPENSIVE method since it compares all pairs of segments in the polygon. This means a N-complexity.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stack</em>&nbsp;</td><td>Outparameter that is filled with the indices of the resulting hull. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>polyIndex</em>&nbsp;</td><td>The index of the polygon within this GfxData. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z493_12" doxytag="GfxData::getAngle"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a27">float64</a> GfxData::getAngle           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>offset</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the angle at given offset. 
<p>
The angle is returned in degrees from the north direction.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>The offset of the polygon where the angle should be calculated. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The angle (in deg) of the segment in the polygon where the offset point is. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="d1" doxytag="GfxData::getAngleNoCoslat"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a27">float64</a> GfxData::getAngleNoCoslat           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ConvexHullNotice *&nbsp;</td>
          <td class="mdname" nowrap> <em>notice1</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ConvexHullNotice *&nbsp;</td>
          <td class="mdname" nowrap> <em>notice2</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>polygon</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [private]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Help method for getConvexHull. 
<p>
Gives the angle from north counted clockwise using the two coordinate pairs that the supplied ConvexHullNotices correspond to. Not using coslat since that leads to errors. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>notice1</em>&nbsp;</td><td>The first ConvexHullNotice, containing the startpoints for the line. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>notice2</em>&nbsp;</td><td>The second ConvexHullNotice, containing the end points for the line. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>polygon</em>&nbsp;</td><td>The polygon of this GfxData that the coordinate indices apply to. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The angle in radians from north counted clockwise <img class="formulaInl" alt="$ [0 , 2\pi[ $" src="form_8.png">. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="e4" doxytag="GfxData::getArcApproximation"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classGfxData.html">GfxData</a>* GfxData::getArcApproximation           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a22">int32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>lat</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a22">int32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>lon</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>startAngle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>stopAngle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>outerRadius</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>innerRadius</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a27">float64</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>angleIncrement</em> = <code>0.2</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a GfxData that is an approximation of an arc or circle sector. 
<p>
Angles are given in degrees and counted from the north direction in clockwise direction.<p>
<dl compact><dt><b>Warning:</b></dt><dd>The GfxData returned by this method is created in this method but <b>must</b> be deleted by the caller!</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lat</em>&nbsp;</td><td>The latitude part of the coordinate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lon</em>&nbsp;</td><td>The longitude part of the coordinate describing the centre of the circle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startAngle</em>&nbsp;</td><td>The start angle in degrees. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stopAngle</em>&nbsp;</td><td>The stop angle in degrees. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>outerRaduis</em>&nbsp;</td><td>The outer radius &lt;it&gt;in mc2-units&lt;/it&gt;. use the constant METER_TO_MC2SCALE in this class to convert from meters. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>innerRaduis</em>&nbsp;</td><td>Optional parameter describing the inner radius &lt;it&gt;in mc2-units&lt;/it&gt;. Default value is 0. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A GfxData approximating the area described by the parameters. NULL is returned upon error. Please note that the GfxData is created inside this method but must be deleted by the caller! </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z493_0" doxytag="GfxData::getAverageNbrMaxTries"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a19">uint16</a> GfxData::getAverageNbrMaxTries           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>polygon</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This fucntion may be used as a a help in method getRandomCoordinateInside. 
<p>
It determines the average number of tries needed when a random coordinate inside a given polygon is wanted. The complexity is linear.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>polygon</em>&nbsp;</td><td>Index for the polygon used.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The average number of tries needed, casted to uint16. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="d2" doxytag="GfxData::getBBox"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool GfxData::getBBox           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classGfxData.html#w0">coordinate_type</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>minLat</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classGfxData.html#w0">coordinate_type</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>maxLat</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classGfxData.html#w0">coordinate_type</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>minLon</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classGfxData.html#w0">coordinate_type</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>maxLon</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [private]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Internal method for getting boundingbox. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z491_4" doxytag="GfxData::getBBoxArea"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="Types_8h.html#a27">float64</a> GfxData::getBBoxArea           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Default implementation uses the getMC2BoundingBix-methods. 
<p>
Could be overrided for better performance in the subclasses,     </td>
  </tr>
</table>
<a class="anchor" name="z491_5" doxytag="GfxData::getBBoxArea_mc2"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="Types_8h.html#a23">uint64</a> GfxData::getBBoxArea_mc2           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="d9" doxytag="GfxData::getBestIndexBetween"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a21">uint32</a> GfxData::getBestIndexBetween           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>polyIndex</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>b</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [private]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Help method to the filtering methods. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>polyIndex</em>&nbsp;</td><td>The polygon index. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>The first coord index. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The last coord index. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The index between a and b that minimizes the crossDistance error. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a16" doxytag="GfxData::getClosed"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool GfxData::getClosed           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>poly</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Implemented in <a class="el" href="classGfxDataFull.html#z499_10">GfxDataFull</a>, <a class="el" href="classGfxDataMultiplePoints.html#z501_10">GfxDataMultiplePoints</a>, <a class="el" href="classGfxDataSingleLine.html#z503_10">GfxDataSingleLine</a>, <a class="el" href="classGfxDataSinglePoint.html#z505_10">GfxDataSinglePoint</a>, and <a class="el" href="classGfxDataSingleSmallPoly.html#z507_10">GfxDataSingleSmallPoly</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a41" doxytag="GfxData::getConvexHull"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classGfxData.html">GfxData</a>* GfxData::getConvexHull           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classGfxData.html">GfxData</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pointSet</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculates the convex hull of a set of points using Jarvi's March method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pointSet</em>&nbsp;</td><td>A GfxData containing the given points </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A GfxData with the convex hull of the set of points. It is a clockwise oriented polygon. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a39" doxytag="GfxData::getConvexHull"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool GfxData::getConvexHull           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classStack.html">Stack</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>stack</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>polygon</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculates the convex hull of a polygon using Grahams scan. 
<p>
The indices of the coordinates that belongs to the convex hull is inserted into the preallocated stack that is given as parameter. The method does not use coslat when calculating the to the points of the polygon. The coslat differs for each coord-pair, which may give an incorrect result, including points in the convex hull although they should not be there. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stack</em>&nbsp;</td><td>The preallocated stack which will be filled with the indices of the coordiantes that makes the convex hull. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>polygon</em>&nbsp;</td><td>The number of the polygon within this GfxData. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True if the the operation was succesful, false otherwise. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z491_0" doxytag="GfxData::getCoordinate"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a21">uint32</a> GfxData::getCoordinate           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classGfxData.html#w0">coordinate_type</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>lat</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classGfxData.html#w0">coordinate_type</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>lon</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the coordinate at given offset. 
<p>
The coordinates are returned via outparameters. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>The offset of the polygon where the coordinate should be calculated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lat</em>&nbsp;</td><td>Outparameter that is set to the latitude part of the coordinate at offset. This is <b>not</b> set if returning false. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lon</em>&nbsp;</td><td>Outparameter that is set to the longitude part of the coordinate at offset. This is <b>not</b> set if returning false. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if the outparameters were not set properly, otherwise the index of the next coordinate following this offset. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="GfxData::getCoordinate"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classMC2Coordinate.html">MC2Coordinate</a> GfxData::getCoordinate           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>i</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets coordinate for a specific polygon and segment. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>polygon number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>segment number </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>coordinate in polygon p and segment i </dd></dl>

<p>
Definition at line <a class="el" href="GfxData_8h-source.html#l00203">203</a> of file <a class="el" href="GfxData_8h-source.html">GfxData.h</a>.
<p>
Referenced by <a class="el" href="OldMapFilter_8h-source.html#l00459">OldMapFilter::filterSegment()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a21" doxytag="GfxData::getCosLat"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="Types_8h.html#a27">float64</a> GfxData::getCosLat           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Implemented in <a class="el" href="classGfxDataFull.html#z499_15">GfxDataFull</a>, <a class="el" href="classGfxDataMultiplePoints.html#z501_15">GfxDataMultiplePoints</a>, <a class="el" href="classGfxDataSingleLine.html#z503_15">GfxDataSingleLine</a>, <a class="el" href="classGfxDataSinglePoint.html#z505_15">GfxDataSinglePoint</a>, and <a class="el" href="classGfxDataSingleSmallPoly.html#z507_15">GfxDataSingleSmallPoly</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a34" doxytag="GfxData::getCosRelativeAngle"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double GfxData::getCosRelativeAngle           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a22">int32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>polyIndex</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>tip</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>q</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Finds the cosine of the relative angle between two consecutive segments in a simple polygon. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>polyIndex</em>&nbsp;</td><td>The index for the polygon used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>Vertex only in first segment </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tip</em>&nbsp;</td><td>Middle vertex, appear in both segments </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>Vertex only in second segment </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Cosine of the angle </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a29" doxytag="GfxData::getGfxDataType"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classGfxData.html#w9">gfxdata_t</a> GfxData::getGfxDataType           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="GfxData_8h-source.html#l00319">319</a> of file <a class="el" href="GfxData_8h-source.html">GfxData.h</a>.
<p>
References <a class="el" href="MC2Logging_8h-source.html#l00169">mc2dbg</a>, and <a class="el" href="Types_8h-source.html#l00034">uint32</a>.    </td>
  </tr>
</table>
<a class="anchor" name="z491_1" doxytag="GfxData::getLastLat"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classGfxData.html#w0">GfxData::coordinate_type</a> GfxData::getLastLat           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>p</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the latitude-part of the last coordinate. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>The polygon to get the last latitude for. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Latitude for the last coordinate. </dd></dl>

<p>
Definition at line <a class="el" href="GfxData_8h-source.html#l01396">1396</a> of file <a class="el" href="GfxData_8h-source.html">GfxData.h</a>.
<p>
References <a class="el" href="classGfxData.html#a6">getLat()</a>, <a class="el" href="classGfxData.html#a9">getNbrCoordinates()</a>, and <a class="el" href="config_8h-source.html#l00296">MC2_ASSERT</a>.    </td>
  </tr>
</table>
<a class="anchor" name="z491_2" doxytag="GfxData::getLastLon"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classGfxData.html#w0">GfxData::coordinate_type</a> GfxData::getLastLon           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>p</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the longitude-part of the last coordinate. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>The polygon to get the last latitude for. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Longitude for the last coordinate. </dd></dl>

<p>
Definition at line <a class="el" href="GfxData_8h-source.html#l01403">1403</a> of file <a class="el" href="GfxData_8h-source.html">GfxData.h</a>.
<p>
References <a class="el" href="classGfxData.html#a7">getLon()</a>, <a class="el" href="classGfxData.html#a9">getNbrCoordinates()</a>, and <a class="el" href="config_8h-source.html#l00296">MC2_ASSERT</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="GfxData::getLat"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classGfxData.html#w0">coordinate_type</a> GfxData::getLat           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>i</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Implemented in <a class="el" href="classGfxDataFull.html#z499_4">GfxDataFull</a>, <a class="el" href="classGfxDataMultiplePoints.html#z501_4">GfxDataMultiplePoints</a>, <a class="el" href="classGfxDataSingleLine.html#z503_4">GfxDataSingleLine</a>, <a class="el" href="classGfxDataSinglePoint.html#z505_4">GfxDataSinglePoint</a>, and <a class="el" href="classGfxDataSingleSmallPoly.html#z507_4">GfxDataSingleSmallPoly</a>.
<p>
Referenced by <a class="el" href="OldMapFilter_8h-source.html#l00459">OldMapFilter::filterSegment()</a>, and <a class="el" href="GfxData_8h-source.html#l01396">getLastLat()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a22" doxytag="GfxData::getLength"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="Types_8h.html#a27">float64</a> GfxData::getLength           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>p</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the length in meters. 
<p>

<p>
Implemented in <a class="el" href="classGfxDataFull.html#z499_16">GfxDataFull</a>, <a class="el" href="classGfxDataMultiplePoints.html#z501_16">GfxDataMultiplePoints</a>, <a class="el" href="classGfxDataSingleLine.html#z503_16">GfxDataSingleLine</a>, <a class="el" href="classGfxDataSinglePoint.html#z505_16">GfxDataSinglePoint</a>, and <a class="el" href="classGfxDataSingleSmallPoly.html#z507_16">GfxDataSingleSmallPoly</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="GfxData::getLon"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classGfxData.html#w0">coordinate_type</a> GfxData::getLon           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>i</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Implemented in <a class="el" href="classGfxDataFull.html#z499_5">GfxDataFull</a>, <a class="el" href="classGfxDataMultiplePoints.html#z501_5">GfxDataMultiplePoints</a>, <a class="el" href="classGfxDataSingleLine.html#z503_5">GfxDataSingleLine</a>, <a class="el" href="classGfxDataSinglePoint.html#z505_5">GfxDataSinglePoint</a>, and <a class="el" href="classGfxDataSingleSmallPoly.html#z507_5">GfxDataSingleSmallPoly</a>.
<p>
Referenced by <a class="el" href="OldMapFilter_8h-source.html#l00459">OldMapFilter::filterSegment()</a>, and <a class="el" href="GfxData_8h-source.html#l01403">getLastLon()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a18" doxytag="GfxData::getMaxLat"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classGfxData.html#w0">coordinate_type</a> GfxData::getMaxLat           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the maximum latitude. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The maximum latitude for the bounded box for this gfxData. </dd></dl>

<p>
Implemented in <a class="el" href="classGfxDataFull.html#z499_12">GfxDataFull</a>, <a class="el" href="classGfxDataMultiplePoints.html#z501_12">GfxDataMultiplePoints</a>, <a class="el" href="classGfxDataSingleLine.html#z503_12">GfxDataSingleLine</a>, <a class="el" href="classGfxDataSinglePoint.html#z505_12">GfxDataSinglePoint</a>, and <a class="el" href="classGfxDataSingleSmallPoly.html#z507_12">GfxDataSingleSmallPoly</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a20" doxytag="GfxData::getMaxLon"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classGfxData.html#w0">coordinate_type</a> GfxData::getMaxLon           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the maximum longitude. 
<p>
We have to remember that minLon can be &lt; maxLon if we are close to London or Paris. So take care when using this function.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The maximum longitude for the bounded box for this gfxData. </dd></dl>

<p>
Implemented in <a class="el" href="classGfxDataFull.html#z499_14">GfxDataFull</a>, <a class="el" href="classGfxDataMultiplePoints.html#z501_14">GfxDataMultiplePoints</a>, <a class="el" href="classGfxDataSingleLine.html#z503_14">GfxDataSingleLine</a>, <a class="el" href="classGfxDataSinglePoint.html#z505_14">GfxDataSinglePoint</a>, and <a class="el" href="classGfxDataSingleSmallPoly.html#z507_14">GfxDataSingleSmallPoly</a>.    </td>
  </tr>
</table>
<a class="anchor" name="z491_3" doxytag="GfxData::getMC2BoundingBox"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool GfxData::getMC2BoundingBox           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classMC2BoundingBox.html">MC2BoundingBox</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>bb</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>polygon</em> = <code>MAX_UINT16</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the bounding box for this GfxData. 
<p>
Note: This function isn't virtual. Strange since <a class="el" href="classGfxDataFull.html">GfxDataFull</a> has a bbox.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bb</em>&nbsp;</td><td>Pointer to the bounding box of this GfxData. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>polygon</em>&nbsp;</td><td>Which polygon of the GfxData the bounding box applies to. Note that when this parameter is specified, the bounding box is calculated on the fly, and it is therefore somewhat more time consuming. If set to MAX_UINT16 then the bounding box applies to all polygons. Defaults to MAX_UINT16 when not specified. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True if the operation was succesful, false otherwise. </dd></dl>

<p>
Reimplemented in <a class="el" href="classGfxDataFull.html#a2">GfxDataFull</a>.
<p>
Referenced by <a class="el" href="MapModuleNotice_8h-source.html#l00219">MapModuleNotice::setGfxData()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a28" doxytag="GfxData::getMemoryUsage"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="Types_8h.html#a21">uint32</a> GfxData::getMemoryUsage           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the memory usage of this object. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes used by this object. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a17" doxytag="GfxData::getMinLat"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classGfxData.html#w0">coordinate_type</a> GfxData::getMinLat           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the minimum latitude. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The minimum latitude for the bounded box for this gfxData. </dd></dl>

<p>
Implemented in <a class="el" href="classGfxDataFull.html#z499_11">GfxDataFull</a>, <a class="el" href="classGfxDataMultiplePoints.html#z501_11">GfxDataMultiplePoints</a>, <a class="el" href="classGfxDataSingleLine.html#z503_11">GfxDataSingleLine</a>, <a class="el" href="classGfxDataSinglePoint.html#z505_11">GfxDataSinglePoint</a>, and <a class="el" href="classGfxDataSingleSmallPoly.html#z507_11">GfxDataSingleSmallPoly</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a19" doxytag="GfxData::getMinLon"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classGfxData.html#w0">coordinate_type</a> GfxData::getMinLon           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the minimum longitude. 
<p>
We have to remember that minLon can be &lt; maxLon if we e.g. are close to London or Paris. So take care when using this function.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The minimum longitude for the bounded box for this gfxData. </dd></dl>

<p>
Implemented in <a class="el" href="classGfxDataFull.html#z499_13">GfxDataFull</a>, <a class="el" href="classGfxDataMultiplePoints.html#z501_13">GfxDataMultiplePoints</a>, <a class="el" href="classGfxDataSingleLine.html#z503_13">GfxDataSingleLine</a>, <a class="el" href="classGfxDataSinglePoint.html#z505_13">GfxDataSinglePoint</a>, and <a class="el" href="classGfxDataSingleSmallPoly.html#z507_13">GfxDataSingleSmallPoly</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a45" doxytag="GfxData::getMultiCoords"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool GfxData::getMultiCoords           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">multimap&lt; <a class="el" href="Types_8h.html#a21">uint32</a>, <a class="el" href="Types_8h.html#a21">uint32</a> &gt; &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>selfTouchCoords</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="GfxData::getNbrCoordinates"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="Types_8h.html#a21">uint32</a> GfxData::getNbrCoordinates           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>poly</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Implemented in <a class="el" href="classGfxDataFull.html#z499_7">GfxDataFull</a>, <a class="el" href="classGfxDataMultiplePoints.html#z501_7">GfxDataMultiplePoints</a>, <a class="el" href="classGfxDataSingleLine.html#z503_7">GfxDataSingleLine</a>, <a class="el" href="classGfxDataSinglePoint.html#z505_7">GfxDataSinglePoint</a>, and <a class="el" href="classGfxDataSingleSmallPoly.html#z507_7">GfxDataSingleSmallPoly</a>.
<p>
Referenced by <a class="el" href="OldMapFilter_8h-source.html#l00459">OldMapFilter::filterSegment()</a>, <a class="el" href="GfxData_8h-source.html#l01396">getLastLat()</a>, and <a class="el" href="GfxData_8h-source.html#l01403">getLastLon()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="GfxData::getNbrPolygons"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="Types_8h.html#a19">uint16</a> GfxData::getNbrPolygons           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Implemented in <a class="el" href="classGfxDataFull.html#z499_6">GfxDataFull</a>, <a class="el" href="classGfxDataMultiplePoints.html#z501_6">GfxDataMultiplePoints</a>, <a class="el" href="classGfxDataSingleLine.html#z503_6">GfxDataSingleLine</a>, <a class="el" href="classGfxDataSinglePoint.html#z505_6">GfxDataSinglePoint</a>, and <a class="el" href="classGfxDataSingleSmallPoly.html#z507_6">GfxDataSingleSmallPoly</a>.    </td>
  </tr>
</table>
<a class="anchor" name="z493_13" doxytag="GfxData::getOffset"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a19">uint16</a> GfxData::getOffset           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a22">int32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>lat</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a22">int32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>lon</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a22">int32</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>latOnPoly</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a22">int32</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>lonOnPoly</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z495_3" doxytag="GfxData::getPointOnConvexHull"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a21">uint32</a> GfxData::getPointOnConvexHull           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>polyIndex</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [private]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Finding the point in the polygon with the highest y-coordinate (latitude). 
<p>
If two points have the same y-coordinate, the one with the highest x-value will be chosen. This point will be a point on the convex hull. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>polyIndex</em>&nbsp;</td><td>Index of the polygon to use. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The index of the coordinate with the specifications above. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a32" doxytag="GfxData::getPolygonCentroid"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool GfxData::getPolygonCentroid           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classMC2Coordinate.html">MC2Coordinate</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>coord</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
above 
<p>

<p>
Definition at line <a class="el" href="GfxData_8h-source.html#l00409">409</a> of file <a class="el" href="GfxData_8h-source.html">GfxData.h</a>.
<p>
References <a class="el" href="RouteRequestData_8h.html#a3a0">coord</a>, <a class="el" href="MC2Coordinate_8h-source.html#l00073">MC2Coordinate::lat</a>, and <a class="el" href="MC2Coordinate_8h-source.html#l00078">MC2Coordinate::lon</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a31" doxytag="GfxData::getPolygonCentroid"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool GfxData::getPolygonCentroid           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a22">int32</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>centroidLat</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a22">int32</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>centroidLon</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Method used for text labeling of features described with closed polygons. 
<p>
It calculates the centroid (the center of gravity) of a closed polygon.<p>
<dl compact><dt><b>Warning:</b></dt><dd>This function does not seem to work for all polygons. It has not been examined when it fails, but I suspect that selfintersecting polygons do not work.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>polygon</em>&nbsp;</td><td>The index for the polygon used </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>centroidLat</em>&nbsp;</td><td>Outparameter. The latitude of the centroid of the polygon </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>centroidLon</em>&nbsp;</td><td>Outparameter. The longitude of the centroid of the polygon </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True if indata is closed and has at least three nodes, false otherwise. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z491_7" doxytag="GfxData::getRandomCoordinateInside"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool GfxData::getRandomCoordinateInside           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classGfxData.html#w0">coordinate_type</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>lat</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classGfxData.html#w0">coordinate_type</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>lon</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>maxTries</em> = <code>1000</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get a random coordinate that is inside any of the polygons in the GfxData. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lat</em>&nbsp;</td><td>Random lateral coordinate inside GfxData. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lon</em>&nbsp;</td><td>Random longitudinal coordinate inside GfxData. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxTries</em>&nbsp;</td><td>Maximum number of attempts to find a coordinate inside the GfxData.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True if a coordinate was found inside the GfxData, false otherwise. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="d3" doxytag="GfxData::getSegment"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int GfxData::getSegment           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>offset</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [private]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the number of the polygon where the offset point is only supports the use of one polygon. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>The offset for the segment </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of the segment at offset. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a42" doxytag="GfxData::getSimplifiedPolygon"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool GfxData::getSimplifiedPolygon           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classStack.html">Stack</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>stack</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>maxDist</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>minDist</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the indices of a simplified CLOSED polygon. 
<p>
These indices are inserted into the preallocated stack that are given as parameter.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stack</em>&nbsp;</td><td>This stack will be filled with the indices of the coordinates to include in the simplified polygon.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>polygon</em>&nbsp;</td><td>The number of the polygon within this GfxData to simplify.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxDist</em>&nbsp;</td><td>The maximum distance between two coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>minDist</em>&nbsp;</td><td>The minimum distance between two coordinates. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True if the stack is filled with indices, false otherwise. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a36" doxytag="GfxData::getSizeInDataBuffer"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a21">uint32</a> GfxData::getSizeInDataBuffer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the size (in bytes) of the GfxData when saved as a <a class="el" href="classDataBuffer.html">DataBuffer</a>. 
<p>
Use this method in conjunction with <a class="el" href="classGfxData.html#a35">save()</a>.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The size (in bytes) of the GfxData when saved as a <a class="el" href="classDataBuffer.html">DataBuffer</a>. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a51" doxytag="GfxData::getTextPosition"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool GfxData::getTextPosition           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classvector.html">vector</a>&lt; <a class="el" href="classMC2BoundingBox.html">MC2BoundingBox</a> &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>objectBBoxes</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classGfxDataFull.html">GfxDataFull</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>tmpGfx2</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classvector.html">vector</a>&lt; <a class="el" href="classGfxData.html">GfxData</a> * &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>gfxTextArray</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="GfxData::getTotalNbrCoordinates"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a21">uint32</a> GfxData::getTotalNbrCoordinates           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="GfxData_8h-source.html#l00190">190</a> of file <a class="el" href="GfxData_8h-source.html">GfxData.h</a>.
<p>
References <a class="el" href="Types_8h-source.html#l00034">uint32</a>.    </td>
  </tr>
</table>
<a class="anchor" name="z491_6" doxytag="GfxData::insideBBox"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool GfxData::insideBBox           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a22">int32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>lat</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a22">int32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>lon</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z493_2" doxytag="GfxData::insidePolygon"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int GfxData::insidePolygon           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classMC2Coordinate.html">MC2Coordinate</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>coord</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>usePolygon</em> = <code>MAX_UINT16</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z493_1" doxytag="GfxData::insidePolygon"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int GfxData::insidePolygon           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classGfxData.html#w0">coordinate_type</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>lat</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classGfxData.html#w0">coordinate_type</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>lon</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>usePolygon</em> = <code>MAX_UINT16</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Determins where a specified point is located relative this polygon (inside, outside or on the boundry). 
<p>
If the optional parameter usePolygon not is set, the given coordinate is checked againas all polygons in this GfxData.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lat</em>&nbsp;</td><td>The latitude part of the position. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lon</em>&nbsp;</td><td>The longitude part of the position. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>usePolygon</em>&nbsp;</td><td>Optional paramter, that if set describes what polygon in ths GfxData that should be used in the calculations. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The returned integer has the following meaning: <dl>
<dt>0 </dt>
<dd>The position is <b>outside</b> the polygon. </dd>
<dt>1 </dt>
<dd>The position is located <b>on the boundry</b> of the polygon. </dd>
<dt>2 </dt>
<dd>The position is <b>inside</b> the polygon. </dd>
</dl>
</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="d8" doxytag="GfxData::maxCrossDistance"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double GfxData::maxCrossDistance           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>polyIndex</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>b</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [private]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Function used in method openPolygonFilter. 
<p>
The line L between points a and b is considered. The distance to L from all the points between a and b is calculated and the maximum distance is determined.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>polyIndex</em>&nbsp;</td><td>Index of the polygon used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k</em>&nbsp;</td><td>Vertex in the open polygon </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>Vertex in the open polygon. Usually located before k. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Vertex in the open polygon. Usually located after k. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The maximum distance. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z493_9" doxytag="GfxData::minSquareDistTo"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a23">uint64</a> GfxData::minSquareDistTo           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classGfxData.html">GfxData</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>otherGfx</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function is the same as the above with the differance that points inside (if the polygon is closed) have their distance set to 0. 
<p>
This function is not to be used on distances where earth no longer can be linearised locally!<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>otherGfx</em>&nbsp;</td><td>The gfxData to check distance to. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The minimum square distance in meters between otherGfx and this object. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="b2" doxytag="GfxData::nbrCoordInSplittedPolygon"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a21">uint32</a> GfxData::nbrCoordInSplittedPolygon           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a22">int32</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>polyVec</em>[]          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Method used in triangulatePolygon method. 
<p>
Determines the number of coordinates of the polygon stored in polyVec.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>polyVec</em>&nbsp;</td><td>The indices of the polygon.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Number of coordinates in polygon. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z493_3" doxytag="GfxData::nbrCornersInsidePolygon"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int GfxData::nbrCornersInsidePolygon           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classMC2BoundingBox.html">MC2BoundingBox</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>bbox</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>maxCorners</em> = <code>4</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>usePolygon</em> = <code>MAX_UINT16</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculates how many of the corners of the bounding box that are inside or at the boundry of the polygon. 
<p>
This function may be a bad idea. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bbox</em>&nbsp;</td><td>The bounding box to check. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxCorners</em>&nbsp;</td><td>Exit when the number of corners reach this value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>usePolygon</em>&nbsp;</td><td>Optional parameter. If set only the supplied polygon in the GfxData will be checked. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nbr of corners inside or at the boundry of the polygons. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a43" doxytag="GfxData::openPolygonFilter"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool GfxData::openPolygonFilter           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classStack.html">Stack</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>newPoly</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>polyIndex</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>maxLatDist</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>maxWayDist</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>minimizeError</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>startIndex</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>endIndex</em> = <code>MAX_UINT32</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the indices of a simplified OPEN polygon. 
<p>
These indices are inserted into the preallocated stack that are given as parameter.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stack</em>&nbsp;</td><td>This stack will be filled with the indices of the coordinates to include in the simplified polygon. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>polyIndex</em>&nbsp;</td><td>The index of the polygon within this GfxData to simplify.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxLatDist</em>&nbsp;</td><td>The maximum deviation (meters) of the given points from a new line. Example: If we want to make a new line from point 1 to point 4 and therefore skip points 2 and 3, the perpendicular distance to points 2 and 3 from the wanted line must be smaller than maxLatDist. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxWayDist</em>&nbsp;</td><td>The maximum distance (meters) between two coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>minimizeError</em>&nbsp;</td><td>[Optional] Default set to false. If true, the maxLatDist will be used as a hint to where it is needed to insert points. The position of the points will be selected so that the crossDistance error is minimized. Will result in a more sophisticated filtering at the cost of a longer processing time. If this parameter is set, the filtering will also work for closed polygons. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startIndex</em>&nbsp;</td><td>[Default 0] Start index in polygon for filtering. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>endIndex</em>&nbsp;</td><td>[Default last index in polygon] Last index in polygon for filtering. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True if the stack is filled with indices, false otherwise. </dd></dl>

<p>
Referenced by <a class="el" href="OldMapFilter_8h-source.html#l00459">OldMapFilter::filterSegment()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="d5" doxytag="GfxData::orientation"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a22">int32</a> GfxData::orientation           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a22">int32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>lat1</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a22">int32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>lon1</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a22">int32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>lat2</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a22">int32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>lon2</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a22">int32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>lat3</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a22">int32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>lon3</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [private]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classGfxData.html#d4">orientation</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="d4" doxytag="GfxData::orientation"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a22">int32</a> GfxData::orientation           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>polyIndex</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>z</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [private]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the orientation of three vertices x, y and z i a polygon. 
<p>
x,y and z are given as indices in the interval [0...n-1], where n is number of vertices. The vectors xy and xz are formed and the z-component of the cross product between them determines the orientation.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>polyIndex</em>&nbsp;</td><td>The index for the polygon used </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>First vertex in the given polygon </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>Second vertex in the given polygon </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>z</em>&nbsp;</td><td>Third vertex in the given polygon </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The orientation in terms of: <dl>
<dt>0 </dt>
<dd>If x,y anz are on a straight line. </dd>
<dt>-1 </dt>
<dd>If orientation is counter clockwise. </dd>
<dt>1 </dt>
<dd>If orientation is clockwise. </dd>
</dl>
</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="GfxData::polyBegin"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classMC2Coordinate.html">iterator</a> GfxData::polyBegin           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>p</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the begin iterator for polygon p. 
<p>

<p>
Implemented in <a class="el" href="classGfxDataFull.html#z499_2">GfxDataFull</a>, <a class="el" href="classGfxDataMultiplePoints.html#z501_2">GfxDataMultiplePoints</a>, <a class="el" href="classGfxDataSingleLine.html#z503_2">GfxDataSingleLine</a>, <a class="el" href="classGfxDataSinglePoint.html#z505_2">GfxDataSinglePoint</a>, and <a class="el" href="classGfxDataSingleSmallPoly.html#z507_2">GfxDataSingleSmallPoly</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="GfxData::polyBegin"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classMC2Coordinate.html">const_iterator</a> GfxData::polyBegin           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>p</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the begin iterator for polygon p. 
<p>

<p>
Implemented in <a class="el" href="classGfxDataFull.html#z499_0">GfxDataFull</a>, <a class="el" href="classGfxDataMultiplePoints.html#z501_0">GfxDataMultiplePoints</a>, <a class="el" href="classGfxDataSingleLine.html#z503_0">GfxDataSingleLine</a>, <a class="el" href="classGfxDataSinglePoint.html#z505_0">GfxDataSinglePoint</a>, and <a class="el" href="classGfxDataSingleSmallPoly.html#z507_0">GfxDataSingleSmallPoly</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="GfxData::polyEnd"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classMC2Coordinate.html">iterator</a> GfxData::polyEnd           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>p</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the end iterator for polygon p. 
<p>

<p>
Implemented in <a class="el" href="classGfxDataFull.html#z499_3">GfxDataFull</a>, <a class="el" href="classGfxDataMultiplePoints.html#z501_3">GfxDataMultiplePoints</a>, <a class="el" href="classGfxDataSingleLine.html#z503_3">GfxDataSingleLine</a>, <a class="el" href="classGfxDataSinglePoint.html#z505_3">GfxDataSinglePoint</a>, and <a class="el" href="classGfxDataSingleSmallPoly.html#z507_3">GfxDataSingleSmallPoly</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="GfxData::polyEnd"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classMC2Coordinate.html">const_iterator</a> GfxData::polyEnd           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>p</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the end iterator for polygon p. 
<p>

<p>
Implemented in <a class="el" href="classGfxDataFull.html#z499_1">GfxDataFull</a>, <a class="el" href="classGfxDataMultiplePoints.html#z501_1">GfxDataMultiplePoints</a>, <a class="el" href="classGfxDataSingleLine.html#z503_1">GfxDataSingleLine</a>, <a class="el" href="classGfxDataSinglePoint.html#z505_1">GfxDataSinglePoint</a>, and <a class="el" href="classGfxDataSingleSmallPoly.html#z507_1">GfxDataSingleSmallPoly</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a47" doxytag="GfxData::polygonArea"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double GfxData::polygonArea           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>polyIndex</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculates the area of a given polygon. 
<p>
Polygon is assumed to be simple (i.e not self intersecting) and small enough for 2D-calculations.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>polyIndex</em>&nbsp;</td><td>Index of the polygon used.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>area of polygon in MC2 units. If GfxData has less than three nodes, -1 is returned. The area is positive if the polygon is clockwise oriented, negative otherwise. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a53" doxytag="GfxData::readPolygons"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void GfxData::readPolygons           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>nbrPolygons</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classDataBuffer.html">DataBuffer</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>dataBuffer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classGenericMap.html">GenericMap</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>map</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Reads the polygons from the dataBuffer. 
<p>

<p>
Implemented in <a class="el" href="classGfxDataFull.html#b0">GfxDataFull</a>, <a class="el" href="classGfxDataMultiplePoints.html#b0">GfxDataMultiplePoints</a>, <a class="el" href="classGfxDataSingleLine.html#b0">GfxDataSingleLine</a>, <a class="el" href="classGfxDataSinglePoint.html#z505_21">GfxDataSinglePoint</a>, and <a class="el" href="classGfxDataSingleSmallPoly.html#b0">GfxDataSingleSmallPoly</a>.    </td>
  </tr>
</table>
<a class="anchor" name="b1" doxytag="GfxData::removePolygonVertex"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void GfxData::removePolygonVertex           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a22">int32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>polyVec</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>nbrCoordInVec</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>VertexPos</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Method used in triangulatePolygon method. 
<p>
The indices of the polygon are store in polyVec. The index at position VertexPos in polyVec is deleted by shifting all the positions after VertexPos one step back. The number of coordinates in the polygon, nbrCoordInVec, should decrease by 1 which is done by inserting -1 at position (nbrCoordInVec - 1).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>polyVec</em>&nbsp;</td><td>The indices of the polygon. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nbrCoordInVec</em>&nbsp;</td><td>Number of coordinates of the polygon, determined by the number nonnegative indices in polyVec. These are stored at the beginning of polyVec. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VertexPos</em>&nbsp;</td><td>The position in polyVec corresponding to the index to be deleted. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a50" doxytag="GfxData::removeTooCloseCoordinates"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classGfxDataFull.html">GfxDataFull</a>* GfxData::removeTooCloseCoordinates           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="Types_8h.html#a24">int64</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>minSqDist</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Another filtering algorithm, does not keep the convexity of the polygon. 
<p>
This means that capes may be cut off. If the distance between two vertices A and B is too close, B is removed and A will be compared to the vertex after B.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>polygon</em>&nbsp;</td><td>The index of the polygon used.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>minSqDist</em>&nbsp;</td><td>The minimum SQUARED distance allowed between two consecutive vertices. Distance is in meters. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a35" doxytag="GfxData::save"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void GfxData::save           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classDataBuffer.html">DataBuffer</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>dataBuffer</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Save the data in a data buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dataBuffer</em>&nbsp;</td><td>The databuffer where the GfxData will be stored. Must be at least <a class="el" href="classGfxData.html#a36">getSizeInDataBuffer()</a> bytes large. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="d6" doxytag="GfxData::segmentIntersect"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool GfxData::segmentIntersect           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>polyIndex</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>p2</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>q1</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>q2</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [private]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Determines if two segments (p1,p2) and (q1,q2) intersect at any point. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p1</em>&nbsp;</td><td>First vertex in first segment </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p2</em>&nbsp;</td><td>Second vertex in first segment </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>q1</em>&nbsp;</td><td>First vertex in second segment </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>q2</em>&nbsp;</td><td>Second vertex in second segment </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>polyIndex</em>&nbsp;</td><td>Index of the polygon used. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True if there is an intersection, false otherwise. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a15" doxytag="GfxData::setClosed"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void GfxData::setClosed           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>poly</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>closed</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Implemented in <a class="el" href="classGfxDataFull.html#z499_9">GfxDataFull</a>, <a class="el" href="classGfxDataMultiplePoints.html#z501_9">GfxDataMultiplePoints</a>, <a class="el" href="classGfxDataSingleLine.html#z503_9">GfxDataSingleLine</a>, <a class="el" href="classGfxDataSinglePoint.html#z505_9">GfxDataSinglePoint</a>, and <a class="el" href="classGfxDataSingleSmallPoly.html#z507_9">GfxDataSingleSmallPoly</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a24" doxytag="GfxData::setLength"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void GfxData::setLength           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a27">float64</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>length</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Note! length is in mm. 
<p>

<p>
Implemented in <a class="el" href="classGfxDataFull.html#z499_19">GfxDataFull</a>, <a class="el" href="classGfxDataMultiplePoints.html#z501_18">GfxDataMultiplePoints</a>, <a class="el" href="classGfxDataSingleLine.html#z503_18">GfxDataSingleLine</a>, <a class="el" href="classGfxDataSinglePoint.html#z505_18">GfxDataSinglePoint</a>, and <a class="el" href="classGfxDataSingleSmallPoly.html#z507_18">GfxDataSingleSmallPoly</a>.    </td>
  </tr>
</table>
<a class="anchor" name="z493_10" doxytag="GfxData::signedSquareDistTo"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a24">int64</a> GfxData::signedSquareDistTo           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classGfxData.html#w0">coordinate_type</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>lat</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classGfxData.html#w0">coordinate_type</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>lon</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>usePolygon</em> = <code>MAX_UINT16</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
As squareDistToLine with the differance that points on the inside of a closed polygon will have their distance counted as negative. 
<p>
This function is not to be used on distances where earth<p>
no longer can be linearised locally!<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lat</em>&nbsp;</td><td>The latitude (in "our" measure system) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lon</em>&nbsp;</td><td>The longitude (in "our" measure system) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The minimum square distance in meters to this object. If (lat, lon) is inside the polygon the returned distance is negative. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z493_11" doxytag="GfxData::signedSquareDistTo_mc2"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a24">int64</a> GfxData::signedSquareDistTo_mc2           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classGfxData.html#w0">coordinate_type</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>lat</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classGfxData.html#w0">coordinate_type</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>lon</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>usePolygon</em> = <code>MAX_UINT16</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z495_0" doxytag="GfxData::simplifyPoly"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool GfxData::simplifyPoly           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classStack.html">Stack</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>newPoly</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>polyIndex</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a24">int64</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>maxSqist</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a24">int64</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>minSqDist</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [private]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculates a simplified hull. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stack</em>&nbsp;</td><td>Outparameter that is filled with the indices of the resulting hull. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>polyIndex</em>&nbsp;</td><td>The index of the polygon within this GfxData. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxSqDist</em>&nbsp;</td><td>The squared maximum distance between two coordinates in the resulting hull. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>minSqDist</em>&nbsp;</td><td>The squared minimum distance between two coordinates in the resulting hull. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True if the newPoly-parameter is filled with indices, false otherwise. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="GfxData::sortPolygons"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool GfxData::sortPolygons           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sort the polygons by the number of coordinates they have. 
<p>
The polygon with the most number coordinates are set to polygon with index 0. <dl compact><dt><b>Returns:</b></dt><dd>True if the polygons are sorted, false otherwise. </dd></dl>

<p>
Implemented in <a class="el" href="classGfxDataFull.html#z499_8">GfxDataFull</a>, <a class="el" href="classGfxDataMultiplePoints.html#z501_8">GfxDataMultiplePoints</a>, <a class="el" href="classGfxDataSingleLine.html#z503_8">GfxDataSingleLine</a>, <a class="el" href="classGfxDataSinglePoint.html#z505_8">GfxDataSinglePoint</a>, and <a class="el" href="classGfxDataSingleSmallPoly.html#z507_8">GfxDataSingleSmallPoly</a>.    </td>
  </tr>
</table>
<a class="anchor" name="b3" doxytag="GfxData::splitPolygon"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void GfxData::splitPolygon           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a22">int32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>polyVec</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>nbrCoordInPoly</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>startIndexPos</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>stopIndexPos</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Method used in triangulatePolygon method. 
<p>
Splits a polygon in two parts. One part is stored in polyVec, the other part is obtained by swapping parameters startIndexPos and stopIndexPos whwn calling this function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>The</em>&nbsp;</td><td>indices of the polygon.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nbrCoordInVec</em>&nbsp;</td><td>Number of coordinates of the polygon, determined by the number nonnegative indices in polyVec. These are stored at the beginning of polyVec. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startIndexPos</em>&nbsp;</td><td>One vertex in polygon which determines where to split polygon. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stopIndexPos</em>&nbsp;</td><td>The other vertex in polygon which determines where to split polygon. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z493_8" doxytag="GfxData::squareDistTo"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a23">uint64</a> GfxData::squareDistTo           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classGfxData.html#w0">coordinate_type</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>lat</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classGfxData.html#w0">coordinate_type</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>lon</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>usePolygon</em> = <code>MAX_UINT16</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function is the same as the above with the differance that points inside (if the polygon is closed) have their distance set to 0. 
<p>
This function is not to be used on distances where earth no longer can be linearised locally!<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lat</em>&nbsp;</td><td>The latitude (in "our" measure system) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lon</em>&nbsp;</td><td>The longitude (in "our" measure system) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The minimum square distance in meters to this object. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z493_7" doxytag="GfxData::squareDistToLine"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a23">uint64</a> GfxData::squareDistToLine           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classGfxData.html#w0">coordinate_type</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>lat</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classGfxData.html#w0">coordinate_type</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>lon</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>usePolygon</em> = <code>MAX_UINT16</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A better name would be squaredDistToBoundry. 
<p>
This funtion takes the distance from the boundry of our current object to a point lat/lon.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lat</em>&nbsp;</td><td>The latitude (in "our" 32bit measure system). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lon</em>&nbsp;</td><td>The longitude (in "our" 32bit measure system). </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The distance in meters squared. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z493_6" doxytag="GfxData::squareDistToLine_mc2"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a23">uint64</a> GfxData::squareDistToLine_mc2           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classGfxData.html#w0">coordinate_type</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>lat</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classGfxData.html#w0">coordinate_type</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>lon</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>usePolygon</em> = <code>MAX_UINT16</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A better name would be squaredDistToBoundry. 
<p>
This funtion takes the distance from the boundry of our current object to a point lat/lon.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lat</em>&nbsp;</td><td>The latitude (in "our" 32bit measure system). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lon</em>&nbsp;</td><td>The longitude (in "our" 32bit measure system). </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The distance in mc2-units, squared. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z493_5" doxytag="GfxData::squareDistWithOffsetToLine"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a23">uint64</a> GfxData::squareDistWithOffsetToLine           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classGfxData.html#w0">coordinate_type</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>lat</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classGfxData.html#w0">coordinate_type</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>lon</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a19">uint16</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>cloestPoly</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>closestI</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a27">float64</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>closestT</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>usePolygon</em> = <code>MAX_UINT16</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A better name would be squaredDistToBoundry. 
<p>
This funtion takes the distance from the boundry of our current object to a point lat/lon.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lat</em>&nbsp;</td><td>The latitude (in "our" 32bit measure system). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lon</em>&nbsp;</td><td>The longitude (in "our" 32bit measure system). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>closestI</em>&nbsp;</td><td>Outparameter that is set to the coordinate in the polygon that is closest to (lat, lon). If equal to MAX_UINT16 when calling, this calculation is not done. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>closestT</em>&nbsp;</td><td>Outparameter that is set to the part of the distance from closestI (E.g. 0 &lt;=&gt; coordinate closetI is closest, 0.5 &lt;=&gt; the closest point to (lat, lon) on the polygon is located between coordinate closestI and closestI+1%nbrCoordinates and 1 &lt;=&gt; coordinate closestI+1%nbrCoordinates is closest. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The distance in meters squared. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z493_4" doxytag="GfxData::squareDistWithOffsetToLine_mc2"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a23">uint64</a> GfxData::squareDistWithOffsetToLine_mc2           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classGfxData.html#w0">coordinate_type</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>lat</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classGfxData.html#w0">coordinate_type</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>lon</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a19">uint16</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>closestPolygon</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>closestI</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a27">float64</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>closestT</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>usePolygon</em> = <code>MAX_UINT16</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A better name would be squaredDistToBoundry. 
<p>
This funtion takes the distance from the boundry of our current object to a point lat/lon.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lat</em>&nbsp;</td><td>The latitude (in "our" 32bit measure system). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lon</em>&nbsp;</td><td>The longitude (in "our" 32bit measure system). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>closestI</em>&nbsp;</td><td>Outparameter that is set to the coordinate in the polygon that is closest to (lat, lon). If equal to MAX_UINT16 when calling, this calculation is not done. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>closestT</em>&nbsp;</td><td>Outparameter that is set to the part of the distance from closestI (E.g. 0 &lt;=&gt; coordinate closetI is closest, 0.5 &lt;=&gt; the closest point to (lat, lon) on the polygon is located between coordinate closestI and closestI+1%nbrCoordinates and 1 &lt;=&gt; coordinate closestI+1%nbrCoordinates is closest. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The distance in mc2-units, squared. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z495_2" doxytag="GfxData::stepIndex"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a21">uint32</a> GfxData::stepIndex           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>step</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a22">int32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a22">int32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>nbrCoord</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [private]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculates the next index in the polygon vector. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>step</em>&nbsp;</td><td>The step size. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>The startindex. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nbrCoord</em>&nbsp;</td><td>The total number of coordinates. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="d10" doxytag="GfxData::triangleArea"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double GfxData::triangleArea           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname" nowrap> <em>d1</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>d2</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>d3</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [private]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculates the are of a triangle with given sides, using Heron's formula. 
<p>
The sum of two sides must always be greater than or equal to the third side. ( triangle inequality)<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>d1</em>&nbsp;</td><td>First sidelength in triangle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>d2</em>&nbsp;</td><td>Second sidelength in triangle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>d3</em>&nbsp;</td><td>Third sidelength in triangle.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Area of triangle if closed, -1 if figure is unbounded. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a48" doxytag="GfxData::triangulatePolygon"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool GfxData::triangulatePolygon           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classStack.html">Stack</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>stack</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Types_8h.html#a21">uint32</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>polyIndex</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This method triangulates a given, simple polygon with N vertices into (N-2) triangles. 
<p>
All the triangles must have all three corners on the boundary of the polygon, i.e no new vertices are created to form a triangle. The expected complexity of the algortithm is N*log(N), worst case complexity is O(N).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stack</em>&nbsp;</td><td>The stack originally contains the indices of a simple, closed polygon. It will be cleared and filled with the indices of all the triangles. The first three indices corrspond to the first triangle, etc.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>polyIndex</em>&nbsp;</td><td>The index of the polygon used to triangulate. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True if the stack is filled with indices, false otherwise. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a27" doxytag="GfxData::updateBBox"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool GfxData::updateBBox           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classGfxData.html#w0">coordinate_type</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>lat</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classGfxData.html#w0">coordinate_type</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>lon</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Implemented in <a class="el" href="classGfxDataFull.html#z499_21">GfxDataFull</a>, <a class="el" href="classGfxDataMultiplePoints.html#z501_20">GfxDataMultiplePoints</a>, <a class="el" href="classGfxDataSingleLine.html#z503_20">GfxDataSingleLine</a>, <a class="el" href="classGfxDataSinglePoint.html#z505_20">GfxDataSinglePoint</a>, and <a class="el" href="classGfxDataSingleSmallPoly.html#z507_20">GfxDataSingleSmallPoly</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a26" doxytag="GfxData::updateBBox"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool GfxData::updateBBox           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Implemented in <a class="el" href="classGfxDataFull.html#z499_20">GfxDataFull</a>, <a class="el" href="classGfxDataMultiplePoints.html#z501_19">GfxDataMultiplePoints</a>, <a class="el" href="classGfxDataSingleLine.html#z503_19">GfxDataSingleLine</a>, <a class="el" href="classGfxDataSinglePoint.html#z505_19">GfxDataSinglePoint</a>, and <a class="el" href="classGfxDataSingleSmallPoly.html#z507_19">GfxDataSingleSmallPoly</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a25" doxytag="GfxData::updateLength"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool GfxData::updateLength           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="Types_8h.html#a19">uint16</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>polindex</em> = <code>MAX_UINT16</code>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculates the lengths of the polygons. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>polindex</em>&nbsp;</td><td>Index of the polygon to update, default: update all polygons. </td></tr>
  </table>
</dl>

<p>
Implemented in <a class="el" href="classGMSGfxData.html#a2">GMSGfxData</a>, <a class="el" href="classGfxDataFull.html#z499_18">GfxDataFull</a>, <a class="el" href="classGfxDataMultiplePoints.html#z501_17">GfxDataMultiplePoints</a>, <a class="el" href="classGfxDataSingleLine.html#z503_17">GfxDataSingleLine</a>, <a class="el" href="classGfxDataSinglePoint.html#z505_17">GfxDataSinglePoint</a>, and <a class="el" href="classGfxDataSingleSmallPoly.html#z507_17">GfxDataSingleSmallPoly</a>.    </td>
  </tr>
</table>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="n2" doxytag="GfxData::GMSPolyUtility"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">friend class <a class="el" href="classGMSPolyUtility.html">GMSPolyUtility</a><code> [friend]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Reimplemented in <a class="el" href="classGMSGfxData.html#n0">GMSGfxData</a>.
<p>
Definition at line <a class="el" href="GfxData_8h-source.html#l01387">1387</a> of file <a class="el" href="GfxData_8h-source.html">GfxData.h</a>.    </td>
  </tr>
</table>
<a class="anchor" name="n1" doxytag="GfxData::MESimulateRouteWindow"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">friend class MESimulateRouteWindow<code> [friend]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="GfxData_8h-source.html#l01386">1386</a> of file <a class="el" href="GfxData_8h-source.html">GfxData.h</a>.    </td>
  </tr>
</table>
<a class="anchor" name="n0" doxytag="GfxData::SimulateRouteWindow"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">friend class SimulateRouteWindow<code> [friend]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="GfxData_8h-source.html#l01385">1385</a> of file <a class="el" href="GfxData_8h-source.html">GfxData.h</a>.    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="GfxData_8h-source.html">GfxData.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Wed Jun 30 10:24:17 2010 for mc2 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
