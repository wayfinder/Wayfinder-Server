<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>mc2: StringUtility.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">Shared</a>&nbsp;/&nbsp;<a class="el" href="dir_000015.html">Utility</a>&nbsp;/&nbsp;<a class="el" href="dir_000016.html">include</a></div>
<h1>StringUtility.h</h1><a href="StringUtility_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">Copyright (c) 1999 - 2010, Vodafone Group Services Ltd</span>
00003 <span class="comment">All rights reserved.</span>
00004 <span class="comment"></span>
00005 <span class="comment">Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
00008 <span class="comment">    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
00009 <span class="comment">    * Neither the name of the Vodafone Group Services Ltd nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
00010 <span class="comment"></span>
00011 <span class="comment">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
00012 <span class="comment">*/</span>
00013 
00014 <span class="preprocessor">#ifndef STRINGUTILITY_H</span>
00015 <span class="preprocessor"></span><span class="preprocessor">#define STRINGUTILITY_H</span>
00016 <span class="preprocessor"></span>
00017 <span class="preprocessor">#include "<a class="code" href="config_8h.html">config.h</a>"</span>
00018 <span class="preprocessor">#include "<a class="code" href="MC2String_8h.html">MC2String.h</a>"</span>
00019 <span class="preprocessor">#include "<a class="code" href="TextIterator_8h.html">TextIterator.h</a>"</span>
00020 <span class="preprocessor">#include "<a class="code" href="TextConversionTables_8h.html">TextConversionTables.h</a>"</span>
00021 <span class="preprocessor">#include "<a class="code" href="UTF8Util_8h.html">UTF8Util.h</a>"</span>
00022 <span class="preprocessor">#include &lt;set&gt;</span>
00023 <span class="preprocessor">#include &lt;regex.h&gt;</span>
00024 
00025 <span class="preprocessor">#ifdef __linux</span>
00026 <span class="preprocessor"></span><span class="preprocessor">   #include &lt;sys/time.h&gt;</span>
00027 <span class="preprocessor">#elif _MSC_VER</span>
00028 <span class="preprocessor"></span><span class="preprocessor">   #include &lt;time.h&gt;</span>
00029 <span class="preprocessor">   #ifdef _DEBUG</span>
00030 <span class="preprocessor"></span><span class="preprocessor">      #pragma warning( disable : 4786 )</span>
00031 <span class="preprocessor"></span><span class="preprocessor">   #endif</span>
00032 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00033 <span class="preprocessor"></span>
<a name="l00034"></a><a class="code" href="StringUtility_8h.html#a0">00034</a> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="DebugRM_8h.html#a7">BP</a>( <span class="keywordtype">bool</span> B ) {
00035    <span class="keywordflow">return</span> B ? <span class="stringliteral">"True"</span> : <span class="stringliteral">"False"</span>;
00036 }
00037 
<a name="l00042"></a><a class="code" href="classStringUtility.html">00042</a> <span class="keyword">class </span><a class="code" href="classStringUtility.html">StringUtility</a> {
00043 <span class="keyword">public</span>:
00052       <span class="keyword">static</span> <a class="code" href="classMC2String.html">MC2String</a> convertIdentToClose(<span class="keyword">const</span> <a class="code" href="classMC2String.html">MC2String</a>&amp; name,
00053                                            <span class="keywordtype">bool</span> keepSpaces = <span class="keyword">false</span>);
00054 
00055       <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="classMC2String.html">MC2String</a> upper(<a class="code" href="Types_8h.html#a21">uint32</a> ucs);
00056       
00057       <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="classMC2String.html">MC2String</a> lower(<a class="code" href="Types_8h.html#a21">uint32</a> ucs);
00058       
00067       <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="classMC2String.html">MC2String</a> copyUpper(<a class="code" href="classutf8TextIterator.html">mc2TextIterator</a> str);
00068 
00077       <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="classMC2String.html">MC2String</a> copyLower(<a class="code" href="classutf8TextIterator.html">mc2TextIterator</a> str);
00078       
00088       <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> strcmp(<span class="keyword">const</span> <span class="keywordtype">char</span>* strA, <span class="keyword">const</span> <span class="keywordtype">char</span>* strB);
00089 
00100       <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> strcasecmp(<span class="keyword">const</span> <a class="code" href="classutf8TextIterator.html">mc2TextIterator</a>&amp; strA,
00101                                    <span class="keyword">const</span> <a class="code" href="classutf8TextIterator.html">mc2TextIterator</a>&amp; strB);
00102 
00116       <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> strncasecmp(<span class="keyword">const</span> <a class="code" href="classutf8TextIterator.html">mc2TextIterator</a>&amp; strA,
00117                                     <span class="keyword">const</span> <a class="code" href="classutf8TextIterator.html">mc2TextIterator</a>&amp; strB,
00118                                     <span class="keywordtype">int</span> n);
00119 
00128       <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">char</span>* strstr( <span class="keyword">const</span> <span class="keywordtype">char</span>* haystack, 
00129                                   <span class="keyword">const</span> <span class="keywordtype">char</span>* needle );
00130 
00139       <span class="keyword">static</span> <span class="keywordtype">char</span>* strchr( <span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keywordtype">int</span> c );
00140 
00149       <span class="keyword">static</span> <span class="keywordtype">char</span>* strrchr( <span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keywordtype">int</span> c );
00150       
00157       <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> trimEnd(<span class="keywordtype">char</span>* s, <span class="keyword">const</span> <span class="keywordtype">char</span>* additional = <span class="stringliteral">""</span>);
00158 
00167       <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">char</span>* trimStart(<span class="keyword">const</span> <span class="keywordtype">char</span>* s, 
00168                                     <span class="keyword">const</span> <span class="keywordtype">char</span>* additional = <span class="stringliteral">""</span>);
00169 
00175       <span class="keyword">static</span> <a class="code" href="classMC2String.html">MC2String</a> trimStartEnd( <span class="keyword">const</span> <span class="keywordtype">char</span>* s,
00176                                      <span class="keyword">const</span> <span class="keywordtype">char</span>* additional = <span class="stringliteral">""</span>);
00177 
00183       <span class="keyword">static</span> <a class="code" href="classMC2String.html">MC2String</a> trimStartEnd( <span class="keyword">const</span> <a class="code" href="classMC2String.html">MC2String</a>&amp; orig,
00184                                      <span class="keyword">const</span> <span class="keywordtype">char</span>* additional = <span class="stringliteral">""</span>);
00185      
00186 
00196    <span class="keyword">static</span> <a class="code" href="classMC2String.html">MC2String</a>&amp; trimStartInPlace(<a class="code" href="classMC2String.html">MC2String</a>&amp; str);
00206    <span class="keyword">static</span> <a class="code" href="classMC2String.html">MC2String</a>&amp; trimEndInPlace(<a class="code" href="classMC2String.html">MC2String</a>&amp; str);
00216    <span class="keyword">static</span> <a class="code" href="classMC2String.html">MC2String</a>&amp; trimInPlace(<a class="code" href="classMC2String.html">MC2String</a>&amp; str);
00217 
00218 
00224       <span class="keyword">static</span> <a class="code" href="classMC2String.html">MC2String</a> makeFirstCapital( <span class="keyword">const</span> <a class="code" href="classMC2String.html">MC2String</a>&amp; str );
00225 
00237       <span class="keyword">static</span> <a class="code" href="classMC2String.html">MC2String</a> makeFirstInWordCapital(<span class="keyword">const</span> <a class="code" href="classMC2String.html">MC2String</a>&amp; str, 
00238                                               <span class="keywordtype">bool</span> makeRomanNumbersUpper = <span class="keyword">false</span>);
00239       
00240       
00241       <span class="keyword">static</span> <span class="keywordtype">int</span> isRomanNumeral(<span class="keyword">const</span> <span class="keywordtype">char</span>* str, <a class="code" href="Types_8h.html#a21">uint32</a> n);
00242 
00243       <span class="keyword">static</span> <span class="keywordtype">void</span> makeRomanNumeralsUpper( <span class="keywordtype">char</span>* str );
00244 
00252       <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">char</span>* newStrDup(<span class="keyword">const</span> <span class="keywordtype">char</span>* s);
00253 
00271          <span class="keyword">static</span> <span class="keywordtype">bool</span> splitSeconds(  <a class="code" href="Types_8h.html#a21">uint32</a> deltaTime, <a class="code" href="Types_8h.html#a21">uint32</a>&amp; hour, 
00272                                     <a class="code" href="Types_8h.html#a21">uint32</a>&amp; minute, <a class="code" href="Types_8h.html#a21">uint32</a>&amp; second);
00273 
00282          <span class="keyword">static</span> <span class="keywordtype">char</span>* splitSeconds(<a class="code" href="Types_8h.html#a21">uint32</a> deltaTime, <span class="keywordtype">char</span>* str);
00284       
00297       <span class="keyword">static</span> <span class="keywordtype">char</span>* strsep(<span class="keywordtype">char</span>** stringp,
00298                           <span class="keyword">const</span> <span class="keywordtype">char</span>* delim);
00299       
00312    <span class="keyword">static</span> <span class="keywordtype">void</span> tokenListToVector( <a class="code" href="classvector.html">vector&lt; char* &gt;</a>&amp; out,
00313                                   <span class="keywordtype">char</span>* list, 
00314                                   <span class="keywordtype">char</span> sep,
00315                                   <span class="keywordtype">bool</span> skipEmptyTokens = <span class="keyword">true</span>,
00316                                   <span class="keywordtype">bool</span> trimStart = <span class="keyword">true</span>);
00317 
00322    <span class="keyword">static</span> <span class="keywordtype">void</span> tokenListToVector( <a class="code" href="classvector.html">vector&lt;MC2String&gt;</a>&amp; splitStr,
00323                                   <span class="keyword">const</span> <a class="code" href="classMC2String.html">MC2String</a>&amp; toSplit,
00324                                   <span class="keywordtype">char</span> sep,
00325                                   <span class="keywordtype">bool</span> skipEmptyTokens = <span class="keyword">true</span>,
00326                                   <span class="keywordtype">bool</span> trimStart = <span class="keyword">true</span> );
00327 
00339    <span class="keyword">static</span> <span class="keywordtype">void</span> splitToVector( <span class="keyword">const</span> <a class="code" href="classMC2String.html">MC2String</a>&amp; toSplit,
00340                               <span class="keywordtype">char</span> separator,
00341                               <a class="code" href="classvector.html">vector&lt; MC2String &gt;</a>&amp; splitStr,
00342                               <span class="keywordtype">bool</span> skipEmptyTookens = <span class="keyword">true</span> );
00343    
00366       <span class="keyword">template</span>&lt;<span class="keyword">class</span> OutIt&gt;
<a name="l00367"></a><a class="code" href="classStringUtility.html#e27">00367</a>       <span class="keyword">static</span> <span class="keywordtype">void</span> strtok(<span class="keyword">const</span> <a class="code" href="classMC2String.html">MC2String</a>&amp; s, <span class="keyword">const</span> <a class="code" href="classMC2String.html">MC2String</a>&amp; delim, OutIt out)
00368       {
00369          MC2String::size_type endpos = 0;
00370          MC2String::size_type startpos = 0;
00371          <span class="keywordflow">while</span>(MC2String::npos != (endpos = s.<a class="code" href="classMC2String.html#a42">find_first_of</a>(delim, startpos))){
00372             *out++ = s.<a class="code" href="classMC2String.html#a54">substr</a>(startpos, endpos - startpos);
00373             startpos = endpos + 1;
00374          }
00375          *out++ = s.<a class="code" href="classMC2String.html#a54">substr</a>(startpos, endpos - startpos);
00376       }
00377       
00386       <span class="keyword">static</span> <span class="keywordtype">bool</span> onlyDigitsInString( <span class="keyword">const</span> <span class="keywordtype">char</span>* str, 
00387                                       <span class="keywordtype">bool</span> ignoreSpace = <span class="keyword">false</span> );
00388 
00394       <span class="keyword">static</span> <span class="keywordtype">bool</span> containsDigit( <span class="keyword">const</span> <span class="keywordtype">char</span>* str );
00395 
00403       <span class="keyword">static</span> <span class="keywordtype">int</span> replaceChar(<span class="keywordtype">char</span> *str,
00404                              <span class="keywordtype">char</span> searchFor,
00405                              <span class="keywordtype">char</span> replaceWith,
00406                              <span class="keywordtype">int</span> stopAt = MAX_INT32 );
00407 
00423       <span class="keyword">static</span> <span class="keywordtype">char</span>* replaceString( <span class="keyword">const</span> <span class="keywordtype">char</span>* source,
00424                                   <span class="keyword">const</span> <span class="keywordtype">char</span>* searchFor,
00425                                   <span class="keyword">const</span> <span class="keywordtype">char</span>* replaceWith,
00426                                   <span class="keywordtype">int</span> maxReplace = 0 );
00427 
00434       <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> isAlNum(uint32 ucs);
00435 
00436       <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> isSpace(uint32 ucs);
00437       
00442       <span class="keyword">static</span> <a class="code" href="Types_8h.html#a21">uint32</a> makeDate( <span class="keyword">const</span> <span class="keywordtype">char</span>* date );
00443 
00453       <span class="keyword">static</span> <span class="keywordtype">int</span> makeDateStr( uint32 time, <span class="keywordtype">char</span>* dateStr, <span class="keywordtype">char</span>* timeStr );
00454 
00464       <span class="keyword">static</span> size_t strftime( <span class="keywordtype">char</span>* s, size_t max, <span class="keyword">const</span> <span class="keywordtype">char</span>* format,
00465                               <span class="keyword">const</span> <span class="keyword">struct</span> tm *tm );
00466 
00470       <span class="keyword">static</span> <a class="code" href="Types_8h.html#a21">uint32</a> <a class="code" href="namespaceTimeUtility.html#a4">convertDate</a>(uint32 year, uint32 month, uint32 day);
00471 
00479       <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">char</span> *strlcat(<span class="keywordtype">char</span> *dest, <span class="keyword">const</span> <span class="keywordtype">char</span> *src, size_t n);
00480 
00492       <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">char</span> *strlcpy(<span class="keywordtype">char</span> *dest, <span class="keyword">const</span> <span class="keywordtype">char</span> *src, size_t n);
00493 
00494 
00504       <span class="keyword">static</span> size_t utf8lcpy( <span class="keywordtype">char</span> *dest, <span class="keyword">const</span> <span class="keywordtype">char</span> *src, size_t n );
00505    
00514       <span class="keyword">static</span> <span class="keywordtype">char</span>* removeAllButDigits( <span class="keyword">const</span> <span class="keywordtype">char</span>* str );
00515 
00519       <span class="keyword">static</span> <span class="keywordtype">void</span> randStr( <span class="keywordtype">char</span>* target, uint32 nbr );
00520 
00528       <span class="keyword">static</span> <a class="code" href="Types_8h.html#a21">uint32</a> wapStr( <span class="keywordtype">char</span>* target, <span class="keyword">const</span> <span class="keywordtype">char</span>* str );
00529 
00538       <span class="keyword">static</span> <span class="keywordtype">void</span> swe2eng( <span class="keywordtype">char</span>* pszTarget, <span class="keyword">const</span> <span class="keywordtype">char</span>* pszSource );
00539 
00540 
00556       <span class="keyword">static</span> <span class="keywordtype">bool</span> base64Encode( <span class="keyword">const</span> <span class="keywordtype">char</span>* input, <span class="keywordtype">char</span>* output,
00557                                 uint32 maxLineLength = MAX_UINT32 );
00558 
00565       <span class="keyword">static</span> <a class="code" href="classMC2String.html">MC2String</a> base64Encode( <span class="keyword">const</span> <a class="code" href="classMC2String.html">MC2String</a>&amp; instr,
00566                                      uint32 maxLineLength = MAX_UINT32 );
00567 
00584       <span class="keyword">static</span> <span class="keywordtype">bool</span> base64Encode( <span class="keyword">const</span> byte* input, uint32 inputLength,
00585                                 <span class="keywordtype">char</span>* output, 
00586                                 uint32 maxLineLength = MAX_UINT32 );
00587       
00588       
00601       <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="namespaceEncoding.html#a0">base64Decode</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* input, byte* output );
00602 
00614       <span class="keyword">static</span> <span class="keywordtype">int</span> URLEncode(<span class="keywordtype">char</span>* outbuf,
00615                            <span class="keyword">const</span> <span class="keywordtype">char</span>* inbuf);
00616 
00628       <span class="keyword">static</span> <span class="keywordtype">int</span> URLEncode(<span class="keywordtype">char</span>* outbuf,
00629                            <span class="keyword">const</span> <span class="keywordtype">char</span>* inbuf,
00630                            <span class="keywordtype">int</span> inlength);
00631 
00635       <span class="keyword">static</span> <a class="code" href="classMC2String.html">MC2String</a> URLEncode( <span class="keyword">const</span> <a class="code" href="classMC2String.html">MC2String</a>&amp; src );
00636       
00637       
00647       <span class="keyword">static</span> <span class="keywordtype">int</span> URLDecode(byte* outbuf,
00648                            <span class="keyword">const</span> <span class="keywordtype">char</span>* inbuf);
00649 
00650 
00665       <span class="keyword">static</span> <span class="keywordtype">char</span>* SQLEscape(<span class="keyword">const</span> <span class="keywordtype">char</span>* src, <span class="keywordtype">char</span>* dest,
00666                              uint32 max = MAX_UINT32, uint32 len = 0);
00667 
00683       <span class="keyword">static</span> <span class="keywordtype">char</span>* SQLEscapeSecure(<span class="keyword">const</span> <span class="keywordtype">char</span>* src, <span class="keywordtype">char</span>* dest, 
00684                                    uint32 max = MAX_UINT32, uint32 len = 0);
00685 
00689       <span class="keyword">static</span> <a class="code" href="classMC2String.html">MC2String</a> SQLEscape( <span class="keyword">const</span> <a class="code" href="classMC2String.html">MC2String</a>&amp; src );
00690 
00694       <span class="keyword">static</span> <a class="code" href="classMC2String.html">MC2String</a> SQLEscapeSecure( <span class="keyword">const</span> <a class="code" href="classMC2String.html">MC2String</a>&amp; src);
00695 
00703       <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> null_strcmp(<span class="keyword">const</span> <span class="keywordtype">char</span>* string1, 
00704                                     <span class="keyword">const</span> <span class="keywordtype">char</span>* string2);
00705 
00714       <span class="keyword">static</span> <span class="keywordtype">bool</span> checkBoolean( <span class="keyword">const</span> <span class="keywordtype">char</span>* str, 
00715                                 <span class="keywordtype">bool</span> defaultValue = <span class="keyword">false</span> );
00716 
00723       <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* booleanAsString( <span class="keywordtype">bool</span> value );
00724 
00732       <span class="keyword">static</span> <span class="keywordtype">bool</span> validEmailAddress( <span class="keyword">const</span> <span class="keywordtype">char</span>* emailAddress );
00733 
00734 
00745       <span class="keyword">static</span> <span class="keywordtype">bool</span> endsWithStr( <span class="keyword">const</span> <span class="keywordtype">char</span>* str, 
00746                                <span class="keyword">const</span> <span class="keywordtype">char</span>* endStr, 
00747                                <span class="keywordtype">bool</span> caseSensitive = <span class="keyword">false</span> );
00748 
00749 
00757       <span class="keyword">static</span> <a class="code" href="Types_8h.html#a21">uint32</a> addMonths( uint32 now, uint32 months );
00758 
00766       <span class="keyword">static</span> <a class="code" href="Types_8h.html#a21">uint32</a> addYears( uint32 now, uint32 years );
00767 
00768 
00776       <span class="keyword">static</span> <span class="keyword">const</span> set&lt;const char*&gt;
00777       stringVectorToCharSet( <span class="keyword">const</span> <a class="code" href="classvector.html">vector&lt; char* &gt;</a>&amp; strVector );
00779 
00780    <span class="keyword">static</span> <span class="keywordtype">int</span> parseCommaSepInts(<a class="code" href="classvector.html">vector&lt;uint32&gt;</a>&amp; result,
00781                                 <span class="keyword">const</span> <span class="keywordtype">char</span>* inStr);
00782 
00783 
00790       <span class="keyword">static</span> <span class="keywordtype">bool</span> validPhonenumber( <span class="keyword">const</span> <span class="keywordtype">char</span>* nbr );
00791 
00792 
00800       <span class="keyword">static</span> <span class="keywordtype">char</span>* cleanPhonenumber( <span class="keyword">const</span> <span class="keywordtype">char</span>* nbr );
00801 
00813       <span class="keyword">static</span> <span class="keywordtype">bool</span> regexp( <span class="keyword">const</span> <span class="keywordtype">char</span> *regex, <span class="keyword">const</span> <span class="keywordtype">char</span> *string,
00814                           <span class="keywordtype">int</span> cflags = REG_EXTENDED, <span class="keywordtype">int</span> eflags = 0 );
00815       <span class="keyword">static</span> <span class="keywordtype">bool</span> regexp( <span class="keyword">const</span> <a class="code" href="classMC2String.html">MC2String</a>&amp; regex, <span class="keyword">const</span> <a class="code" href="classMC2String.html">MC2String</a>&amp; string,
00816                           <span class="keywordtype">int</span> cflags = REG_EXTENDED, <span class="keywordtype">int</span> eflags = 0 );
00817 
00830       <span class="keyword">static</span> <span class="keywordtype">bool</span> regexp( <span class="keyword">const</span> <span class="keywordtype">char</span> *regex, <span class="keyword">const</span> <span class="keywordtype">char</span> *string,
00831                           uint32 nbrMatches,
00832                           <a class="code" href="classvector.html">vector&lt; MC2String &gt;</a>&amp; matches,
00833                           <span class="keywordtype">int</span> cflags = REG_EXTENDED, <span class="keywordtype">int</span> eflags = 0 );
00834       <span class="keyword">static</span> <span class="keywordtype">bool</span> regexp( <span class="keyword">const</span> <a class="code" href="classMC2String.html">MC2String</a>&amp; regex, <span class="keyword">const</span> <a class="code" href="classMC2String.html">MC2String</a>&amp; string,
00835                           uint32 nbrMatches,
00836                           std::vector&lt; std::string &gt;&amp; matches,
00837                           <span class="keywordtype">int</span> cflags = REG_EXTENDED, <span class="keywordtype">int</span> eflags = 0 );
00838 
00839 
00852       <span class="keyword">static</span> <span class="keywordtype">bool</span> regexpWholeBracket( 
00853          <span class="keyword">const</span> <span class="keywordtype">char</span> *regex, <span class="keyword">const</span> <span class="keywordtype">char</span> *string,
00854          <span class="keywordtype">int</span> cflags = REG_EXTENDED, <span class="keywordtype">int</span> eflags = 0 );
00855       <span class="keyword">static</span> <span class="keywordtype">bool</span> regexpWholeBracket( 
00856          <span class="keyword">const</span> <a class="code" href="classMC2String.html">MC2String</a>&amp; regex, <span class="keyword">const</span> <a class="code" href="classMC2String.html">MC2String</a>&amp; string,
00857          <span class="keywordtype">int</span> cflags = REG_EXTENDED, <span class="keywordtype">int</span> eflags = 0 );
00858 
00866       <span class="keyword">static</span> <span class="keywordtype">bool</span> regexpCheck( <span class="keyword">const</span> <span class="keywordtype">char</span> *regex,
00867                                <a class="code" href="classMC2String.html">MC2String</a>&amp; error, <span class="keywordtype">int</span> cflags = REG_EXTENDED );
00868       <span class="keyword">static</span> <span class="keywordtype">bool</span> regexpCheck( <span class="keyword">const</span> <a class="code" href="classMC2String.html">MC2String</a>&amp; regex,
00869                                <a class="code" href="classMC2String.html">MC2String</a>&amp; error, <span class="keywordtype">int</span> cflags = REG_EXTENDED );
00870 
00877    <span class="keyword">static</span> <a class="code" href="classMC2String.html">MC2String</a> decodeHtmlString( <span class="keyword">const</span> <a class="code" href="classMC2String.html">MC2String</a>&amp; str );
00878 
00879   <span class="keyword">private</span>:
00885       <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* upperNoAlloc( uint32 ucs, <span class="keywordtype">char</span>* maybe_used );
00886 
00890       <a class="code" href="classStringUtility.html">StringUtility</a>();
00891 
00892 };
00893 
00894 
00895 <span class="comment">// -----------------------------------------------------------------------</span>
00896 <span class="comment">//                                     Implementation of inlined methods -</span>
00897 
00898 <span class="keywordtype">int</span>
<a name="l00899"></a><a class="code" href="classStringUtility.html#e57">00899</a> <a class="code" href="classStringUtility.html#e57">StringUtility::null_strcmp</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* string1, <span class="keyword">const</span> <span class="keywordtype">char</span>* string2)
00900 {
00901    <span class="keywordflow">if</span> ( string1 == NULL &amp;&amp; string2 != NULL )
00902       <span class="keywordflow">return</span> -1;
00903    <span class="keywordflow">if</span> ( string1 != NULL &amp;&amp; string2 == NULL )
00904       <span class="keywordflow">return</span> 1;
00905    <span class="keywordflow">if</span> ( string1 == NULL &amp;&amp; string2 == NULL )
00906       <span class="keywordflow">return</span> 0;
00907    <span class="keywordflow">return</span> <a class="code" href="classStringUtility.html#e6">StringUtility::strcasecmp</a>(string1, string2);
00908 }
00909 
00910 <span class="keyword">inline</span> <span class="keywordtype">char</span> *
<a name="l00911"></a><a class="code" href="classStringUtility.html#e38">00911</a> <a class="code" href="classStringUtility.html#e38">StringUtility::strlcat</a>(<span class="keywordtype">char</span> *dest, <span class="keyword">const</span> <span class="keywordtype">char</span> *src, size_t n)
00912 {
00913    <span class="comment">// inefficient implementation,</span>
00914    <span class="comment">// to be replaced by standard library function strlcat</span>
00915    size_t destLen = strlen(dest);
00916    strncat(dest, src, n);  <span class="comment">// overwrites the terminating null of dest.</span>
00917    <span class="keywordflow">if</span> (destLen &gt; 0) {
00918       dest[destLen+n] = <span class="charliteral">'\0'</span>;
00919    }
00920    <span class="keywordflow">return</span> dest;
00921 }
00922 
00923 <span class="keyword">inline</span> <span class="keywordtype">char</span> *
<a name="l00924"></a><a class="code" href="classStringUtility.html#e39">00924</a> <a class="code" href="classStringUtility.html#e39">StringUtility::strlcpy</a>(<span class="keywordtype">char</span> *dest, <span class="keyword">const</span> <span class="keywordtype">char</span> *src, size_t n)
00925 {
00926    <span class="comment">// inefficient implementation,</span>
00927    <span class="comment">// to be replaced by standard library function strlcpy</span>
00928    strncpy(dest, src, n);
00929    <span class="keywordflow">if</span> (n &gt; 0) {
00930       dest[n-1] = <span class="charliteral">'\0'</span>;
00931    }
00932    <span class="keywordflow">return</span> dest;
00933 }
00934 
00935 
00936 <span class="keyword">inline</span> <span class="keywordtype">int</span> 
<a name="l00937"></a><a class="code" href="classStringUtility.html#e5">00937</a> <a class="code" href="classStringUtility.html#e5">StringUtility::strcmp</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* strA, <span class="keyword">const</span> <span class="keywordtype">char</span>* strB)
00938 {
00939    return ::strcmp(strA, strB);
00940 }
00941 
00942 <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span>*
<a name="l00943"></a><a class="code" href="classStringUtility.html#h0">00943</a> <a class="code" href="classStringUtility.html#h0">StringUtility::upperNoAlloc</a>( uint32 ucs, <span class="keywordtype">char</span>* maybe_used )
00944 {
00945    <a class="code" href="structTextConversionTables_1_1convTableFindRes.html">TextConversionTables::convTableFindRes</a> result =
00946       <a class="code" href="classTextConversionTables.html#e0">TextConversionTables::findInTable</a>(TextConversionTables::c_upperTable,
00947                                         ucs);
00948    <span class="keywordflow">if</span> ( result.<a class="code" href="structTextConversionTables_1_1convTableFindRes.html#o0">resString</a> != NULL ) {
00949       <span class="comment">// This one points into the table</span>
00950       <span class="keywordflow">return</span> result.<a class="code" href="structTextConversionTables_1_1convTableFindRes.html#o0">resString</a>;
00951    } <span class="keywordflow">else</span> {
00952       <span class="comment">// Put the original character into the buffer.</span>
00953       <a class="code" href="classUTF8Util.html#e17">UTF8Util::unicodeToUtf8</a>( ucs, maybe_used );
00954       <span class="keywordflow">return</span> maybe_used;
00955    }
00956 }
00957 
00958 <span class="keyword">inline</span> <span class="keywordtype">int</span>
<a name="l00959"></a><a class="code" href="classStringUtility.html#e6">00959</a> <a class="code" href="classStringUtility.html#e6">StringUtility::strcasecmp</a>( <span class="keyword">const</span> <a class="code" href="classutf8TextIterator.html">mc2TextIterator</a>&amp; strA,
00960                            <span class="keyword">const</span> <a class="code" href="classutf8TextIterator.html">mc2TextIterator</a>&amp; strB )
00961 {
00962    <span class="comment">// ===============================================================</span>
00963    <span class="comment">// This is copied to the strncasecmp-method!                     =</span>
00964    <span class="comment">// ===============================================================</span>
00965 
00966    <span class="comment">// Initiate the return value</span>
00967    <span class="keywordtype">int</span> res = 0;
00968    <span class="keywordtype">char</span> utf8a[8]; <span class="comment">// I guess 7 would do here.</span>
00969    <span class="keywordtype">char</span> utf8b[8];
00970    <a class="code" href="classutf8TextIterator.html">mc2TextIterator</a> itA(strA);
00971    <a class="code" href="classutf8TextIterator.html">mc2TextIterator</a> itB(strB);
00972    <a class="code" href="Types_8h.html#a21">uint32</a> unicodeA = *itA;
00973    <a class="code" href="Types_8h.html#a21">uint32</a> unicodeB = *itB;
00974 
00975    <span class="keywordflow">while</span>(((res = <a class="code" href="classStringUtility.html#e5">strcmp</a>(<a class="code" href="classStringUtility.html#h0">upperNoAlloc</a>(unicodeA, utf8a),
00976                         <a class="code" href="classStringUtility.html#h0">upperNoAlloc</a>(unicodeB, utf8b) ) ) == 0)  &amp;&amp;
00977          (unicodeA != 0) &amp;&amp; (unicodeB != 0) )
00978    {
00979       ++itA;
00980       ++itB;
00981       unicodeA = *itA;
00982       unicodeB = *itB;
00983    }
00984    
00985    <span class="comment">// Return the value</span>
00986    <span class="keywordflow">return</span> res;
00987 }
00988 
00989 <span class="keyword">inline</span> <span class="keywordtype">int</span>
<a name="l00990"></a><a class="code" href="classStringUtility.html#e7">00990</a> <a class="code" href="classStringUtility.html#e7">StringUtility::strncasecmp</a>(<span class="keyword">const</span> <a class="code" href="classutf8TextIterator.html">mc2TextIterator</a>&amp; strA,
00991                            <span class="keyword">const</span> <a class="code" href="classutf8TextIterator.html">mc2TextIterator</a>&amp; strB,
00992                            <span class="keywordtype">int</span> n)
00993 {
00994    <span class="comment">// ===============================================================</span>
00995    <span class="comment">// This is more or less a plain copy of the strcasecmp-method,   =</span>
00996    <span class="comment">// the reason to copy is to not make that method slower...       =</span>
00997    <span class="comment">// ===============================================================</span>
00998    
00999 <span class="comment">// Initiate the return value</span>
01000    <span class="keywordtype">int</span> res = 0;
01001    <span class="keywordtype">int</span> pos = 1;
01002    <span class="keywordtype">char</span> utf8a[8]; <span class="comment">// I guess 7 would do here.</span>
01003    <span class="keywordtype">char</span> utf8b[8];
01004    <a class="code" href="classutf8TextIterator.html">mc2TextIterator</a> itA(strA);
01005    <a class="code" href="classutf8TextIterator.html">mc2TextIterator</a> itB(strB);
01006    <a class="code" href="Types_8h.html#a21">uint32</a> unicodeA = *itA;
01007    <a class="code" href="Types_8h.html#a21">uint32</a> unicodeB = *itB;
01008 
01009    <span class="keywordflow">while</span>(((res = <a class="code" href="classStringUtility.html#e5">strcmp</a>(<a class="code" href="classStringUtility.html#h0">upperNoAlloc</a>(unicodeA, utf8a),
01010                         <a class="code" href="classStringUtility.html#h0">upperNoAlloc</a>(unicodeB, utf8b) ) ) == 0)  &amp;&amp;
01011          (unicodeA != 0) &amp;&amp; (unicodeB != 0) &amp;&amp; (n &gt; pos++) )
01012    {
01013       ++itA;
01014       ++itB;
01015       unicodeA = *itA;
01016       unicodeB = *itB;
01017    } 
01018 
01019    <span class="comment">// Return the value</span>
01020    <span class="keywordflow">return</span> res;
01021 }
01022 
01023 <span class="keyword">inline</span> <span class="keywordtype">char</span>* 
<a name="l01024"></a><a class="code" href="classStringUtility.html#e8">01024</a> <a class="code" href="classStringUtility.html#e8">StringUtility::strstr</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* haystack, <span class="keyword">const</span> <span class="keywordtype">char</span>* needle ) 
01025 {
01026    <span class="keywordflow">return</span> const_cast&lt;char*&gt;(::strstr( haystack, needle ));   
01027 }
01028 
01029 <span class="keyword">inline</span> <span class="keywordtype">char</span>*
<a name="l01030"></a><a class="code" href="classStringUtility.html#e9">01030</a> <a class="code" href="classStringUtility.html#e9">StringUtility::strchr</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keywordtype">int</span> c ) {
01031    <span class="keywordflow">return</span> const_cast&lt;char*&gt;(::strchr( s, c ));
01032 }
01033 
01034 <span class="keyword">inline</span> <span class="keywordtype">char</span>*
<a name="l01035"></a><a class="code" href="classStringUtility.html#e10">01035</a> <a class="code" href="classStringUtility.html#e10">StringUtility::strrchr</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keywordtype">int</span> c ) {
01036    <span class="keywordflow">return</span> const_cast&lt;char*&gt;(::strrchr( s, c ));
01037 }
01038 
01039 <span class="keyword">inline</span> <span class="keywordtype">void</span> 
<a name="l01040"></a><a class="code" href="classStringUtility.html#e11">01040</a> <a class="code" href="classStringUtility.html#e11">StringUtility::trimEnd</a>(<span class="keywordtype">char</span>* s, <span class="keyword">const</span> <span class="keywordtype">char</span>* additional) 
01041 {
01042    <span class="keywordflow">if</span> ( s != NULL &amp;&amp; s[ 0 ] != <span class="charliteral">'\0'</span> ) {
01043       <a class="code" href="Types_8h.html#a21">uint32</a> tmp = strlen(s)-1;
01044       <span class="keywordflow">while</span> ( ( isspace(s[tmp]) || <a class="code" href="classStringUtility.html#e9">strchr</a>(additional, s[tmp]) != NULL ) &amp;&amp; 
01045               (tmp &gt; 0)) {
01046          s[tmp] = <span class="charliteral">'\0'</span>;
01047          tmp--;
01048       }
01049    }
01050 }
01051 
01052 
01053 <span class="keyword">inline</span> <span class="keywordtype">char</span>* 
<a name="l01054"></a><a class="code" href="classStringUtility.html#e12">01054</a> <a class="code" href="classStringUtility.html#e12">StringUtility::trimStart</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* s, <span class="keyword">const</span> <span class="keywordtype">char</span>* additional) 
01055 {
01056    <span class="keywordflow">if</span> (s != NULL) {
01057       <a class="code" href="Types_8h.html#a21">uint32</a> tmp = 0;
01058       <span class="keywordflow">while</span> ( (s[tmp] != <span class="charliteral">'\0'</span>) &amp;&amp; 
01059               (isspace(s[tmp]) || <a class="code" href="classStringUtility.html#e9">strchr</a>(additional, s[tmp]) != NULL) ) {
01060          tmp++;
01061       }
01062       <span class="keywordflow">return</span> ( (<span class="keywordtype">char</span>*) &amp;(s[tmp]));
01063    } <span class="keywordflow">else</span> {
01064       <span class="keywordflow">return</span> (NULL);
01065    }
01066 }
01067 
01068 
01069 <span class="keyword">inline</span> <a class="code" href="classMC2String.html">MC2String</a>&amp; 
<a name="l01070"></a><a class="code" href="classStringUtility.html#e15">01070</a> <a class="code" href="classStringUtility.html#e15">StringUtility::trimStartInPlace</a>(<a class="code" href="classMC2String.html">MC2String</a>&amp; str)
01071 {
01072    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classMC2String.html">MC2String</a> remove(<span class="stringliteral">" \t\n\r\f\v"</span>);
01073    <span class="keywordflow">if</span>( str.<a class="code" href="classMC2String.html#a9">empty</a>() ){
01074       <span class="keywordflow">return</span> str;
01075    }
01076 
01077    MC2String::size_type first = str.<a class="code" href="classMC2String.html#a38">find_first_not_of</a>( remove );
01078    <span class="keywordflow">if</span>( first != MC2String::npos ){
01079       str.<a class="code" href="classMC2String.html#a28">erase</a>( 0, first );
01080    } <span class="keywordflow">else</span> <span class="keywordflow">if</span>( remove.<a class="code" href="classMC2String.html#d1">find</a>( str[0] ) != MC2String::npos ){
01081       str.<a class="code" href="classMC2String.html#a10">clear</a>();
01082    }
01083 
01084    <span class="keywordflow">return</span> str;
01085 }
01086 
01087 <span class="keyword">inline</span> <a class="code" href="classMC2String.html">MC2String</a>&amp; 
<a name="l01088"></a><a class="code" href="classStringUtility.html#e16">01088</a> <a class="code" href="classStringUtility.html#e16">StringUtility::trimEndInPlace</a>(<a class="code" href="classMC2String.html">MC2String</a>&amp; str)
01089 {
01090    <span class="comment">//same characters as isspace()</span>
01091    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classMC2String.html">MC2String</a> remove(<span class="stringliteral">" \t\n\r\f\v"</span>);
01092    <span class="keywordflow">if</span>( str.<a class="code" href="classMC2String.html#a9">empty</a>() ){
01093       <span class="keywordflow">return</span> str;
01094    }
01095 
01096    MC2String::size_type last = str.<a class="code" href="classMC2String.html#a50">find_last_not_of</a>( remove );
01097 
01098    <span class="keywordflow">if</span>( last != MC2String::npos ){
01099       str.<a class="code" href="classMC2String.html#a28">erase</a>( last + 1, MC2String::npos );
01100    } <span class="keywordflow">else</span> <span class="keywordflow">if</span>( remove.<a class="code" href="classMC2String.html#d1">find</a>( str[0] ) != MC2String::npos ){
01101       str.<a class="code" href="classMC2String.html#a10">clear</a>();
01102    }
01103    <span class="keywordflow">return</span> str;
01104 }
01105 
01106 <span class="keyword">inline</span> <a class="code" href="classMC2String.html">MC2String</a>&amp; 
<a name="l01107"></a><a class="code" href="classStringUtility.html#e17">01107</a> <a class="code" href="classStringUtility.html#e17">StringUtility::trimInPlace</a>(<a class="code" href="classMC2String.html">MC2String</a>&amp; str)
01108 {
01109    <span class="keywordflow">return</span> <a class="code" href="classStringUtility.html#e16">trimEndInPlace</a>( <a class="code" href="classStringUtility.html#e15">trimStartInPlace</a>( str ) );
01110 }
01111 
01112 <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l01113"></a><a class="code" href="classStringUtility.html#e32">01113</a> <a class="code" href="classStringUtility.html#e32">StringUtility::isAlNum</a>(uint32 ucs)
01114 {
01115    <span class="keywordflow">if</span>( ucs &lt; 256 ) {
01116       <a class="code" href="Types_8h.html#a25">byte</a> ch = <a class="code" href="Types_8h.html#a25">byte</a>(ucs);
01117       <span class="keywordflow">if</span> ( ch == <a class="code" href="Types_8h.html#a25">byte</a>(<span class="charliteral">'§'</span>) )
01118          <span class="keywordflow">return</span> <span class="keyword">false</span>;
01119       <span class="keywordflow">return</span> ((ch &gt;  <span class="charliteral">'/'</span>) &amp;&amp;
01120               !((ch &gt;= <span class="charliteral">':'</span>) &amp;&amp;
01121                 (ch &lt;= <span class="charliteral">'@'</span>)) &amp;&amp;
01122               !((ch &gt;= <span class="charliteral">'['</span>) &amp;&amp;
01123                 (ch &lt;= <span class="charliteral">'`'</span>)) &amp;&amp;
01124               !((ch &gt;= <span class="charliteral">'{'</span>) &amp;&amp;
01125                 (ch &lt;= 126) &amp;&amp;
01126                 (ch != 127)) &amp;&amp;
01127               !((ch &gt;= 128) &amp;&amp;
01128                 (ch &lt;= 191)) &amp;&amp;
01129               ! (ch == ((byte) <span class="charliteral">'¤'</span>) ));
01130    } <span class="keywordflow">else</span> {
01131       <a class="code" href="structTextConversionTables_1_1convTableFindRes.html">TextConversionTables::convTableFindRes</a> result =
01132          <a class="code" href="classTextConversionTables.html#e0">TextConversionTables::findInTable</a>(
01133                                     TextConversionTables::c_removeStrange,
01134                                     ucs);
01135       <span class="keywordflow">if</span>( result.<a class="code" href="structTextConversionTables_1_1convTableFindRes.html#o0">resString</a> != NULL )
01136          <span class="keywordflow">return</span> <span class="keyword">true</span>;
01137       <span class="keywordflow">else</span> {
01138          <span class="keywordflow">return</span> <span class="keyword">false</span>;
01139       }
01140    }
01141 }
01142 
01143 <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l01144"></a><a class="code" href="classStringUtility.html#e33">01144</a> <a class="code" href="classStringUtility.html#e33">StringUtility::isSpace</a>(uint32 ucs)
01145 {
01146    <span class="keywordflow">if</span>( ucs &lt; 256 ) {
01147       <span class="keywordflow">return</span> isspace(<span class="keywordtype">char</span>(ucs));
01148    } <span class="keywordflow">else</span> {
01149       <span class="keywordflow">return</span> <span class="keyword">false</span>;
01150    }
01151 }
01152 
01153 <span class="keyword">inline</span> <a class="code" href="classMC2String.html">MC2String</a>
<a name="l01154"></a><a class="code" href="classStringUtility.html#e1">01154</a> <a class="code" href="classStringUtility.html#e1">StringUtility::upper</a>(uint32 ucs) {
01155    <a class="code" href="structTextConversionTables_1_1convTableFindRes.html">TextConversionTables::convTableFindRes</a> result =
01156       <a class="code" href="classTextConversionTables.html#e0">TextConversionTables::findInTable</a>(TextConversionTables::c_upperTable,
01157                                         ucs);
01158    <span class="keywordflow">if</span>( result.<a class="code" href="structTextConversionTables_1_1convTableFindRes.html#o0">resString</a> != NULL ) {
01159       <span class="keywordflow">return</span> <a class="code" href="classUTF8Util.html#e12">UTF8Util::utf8ToMc2</a>( result.<a class="code" href="structTextConversionTables_1_1convTableFindRes.html#o0">resString</a> );
01160    } <span class="keywordflow">else</span> {
01161       <span class="keywordflow">return</span> <a class="code" href="classUTF8Util.html#e16">UTF8Util::ucsToMc2</a>(ucs);
01162    }
01163 }
01164 
01165 <span class="keyword">inline</span> <a class="code" href="classMC2String.html">MC2String</a>
<a name="l01166"></a><a class="code" href="classStringUtility.html#e2">01166</a> <a class="code" href="classStringUtility.html#e2">StringUtility::lower</a>(uint32 ucs) {   
01167    <a class="code" href="structTextConversionTables_1_1convTableFindRes.html">TextConversionTables::convTableFindRes</a> result =
01168       <a class="code" href="classTextConversionTables.html#e0">TextConversionTables::findInTable</a>(TextConversionTables::c_lowerTable,
01169                                         ucs);
01170    <span class="keywordflow">if</span>( result.<a class="code" href="structTextConversionTables_1_1convTableFindRes.html#o0">resString</a> != NULL ){
01171       <span class="keywordflow">return</span> <a class="code" href="classUTF8Util.html#e12">UTF8Util::utf8ToMc2</a>( result.<a class="code" href="structTextConversionTables_1_1convTableFindRes.html#o0">resString</a> );
01172    } <span class="keywordflow">else</span> {
01173       <span class="keywordflow">return</span> <a class="code" href="classUTF8Util.html#e16">UTF8Util::ucsToMc2</a>(ucs);
01174    }      
01175 }
01176 
01177 <span class="keyword">inline</span> <a class="code" href="classMC2String.html">MC2String</a>
<a name="l01178"></a><a class="code" href="classStringUtility.html#e3">01178</a> <a class="code" href="classStringUtility.html#e3">StringUtility::copyUpper</a>(<a class="code" href="classutf8TextIterator.html">mc2TextIterator</a> it)
01179 {
01180    <a class="code" href="classMC2String.html">MC2String</a> retVal;
01181    <span class="keywordflow">while</span>( *it != 0 ) {
01182       <a class="code" href="Types_8h.html#a21">uint32</a> ucs = *it;
01183       retVal += <a class="code" href="classStringUtility.html#e1">upper</a>(ucs);
01184       ++it;
01185    }
01186    <span class="keywordflow">return</span> retVal;
01187 }
01188 
01189 <span class="keyword">inline</span> <a class="code" href="classMC2String.html">MC2String</a>
<a name="l01190"></a><a class="code" href="classStringUtility.html#e4">01190</a> <a class="code" href="classStringUtility.html#e4">StringUtility::copyLower</a>(<a class="code" href="classutf8TextIterator.html">mc2TextIterator</a> it)
01191 {
01192    <a class="code" href="classMC2String.html">MC2String</a> retVal;
01193    <span class="keywordflow">while</span>( *it != 0 ) {
01194       <a class="code" href="Types_8h.html#a21">uint32</a> ucs = *it;
01195       retVal += <a class="code" href="classStringUtility.html#e2">lower</a>(ucs);
01196       ++it;
01197    }
01198    <span class="keywordflow">return</span> retVal;
01199 }
01200 
01201 <span class="keyword">inline</span> <span class="keywordtype">char</span>*
<a name="l01202"></a><a class="code" href="classStringUtility.html#e22">01202</a> <a class="code" href="classStringUtility.html#e22">StringUtility::newStrDup</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* s)
01203 {
01204    <span class="keywordtype">char</span>* theDupe = <span class="keyword">new</span> <span class="keywordtype">char</span>[strlen(s) + 1];
01205    strcpy( theDupe, s );
01206    <span class="keywordflow">return</span> theDupe;
01207 }
01208 
01209 
01210 <span class="preprocessor">#endif // STRINGUTULITY_H </span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Jun 30 10:11:51 2010 for mc2 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
